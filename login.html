<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Login - NOVAGAPP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="style.css">

  <!-- ✅ SUPABASE SDK FIRST -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="public-config.js"></script>

  <!-- ✅ SINGLE CLIENT (GLOBAL) -->
  <script>
    (function(){
      function normalizeConfig(raw){
        return {
          supabaseUrl: String(raw?.supabaseUrl || "").trim(),
          supabaseAnonKey: String(raw?.supabaseAnonKey || "").trim()
        };
      }

      async function ensureSupaClient(){
        if(window.supa){
          return window.supa;
        }

        let cfg = normalizeConfig(window.NOVA_PUBLIC_CONFIG || window.__NOVA_PUBLIC_CONFIG__ || {});
        if((!cfg.supabaseUrl || !cfg.supabaseAnonKey) && typeof window.getNovaPublicConfig === "function"){
          try{
            cfg = normalizeConfig(await window.getNovaPublicConfig(true));
          }catch(_){ }
        }

        if(!cfg.supabaseUrl || !cfg.supabaseAnonKey){
          throw new Error("Supabase public config missing");
        }

        window.supa = supabase.createClient(
          cfg.supabaseUrl,
          cfg.supabaseAnonKey,
          {
            auth:{
              persistSession:true,
              autoRefreshToken:true,
              detectSessionInUrl:true
            }
          }
        );
        return window.supa;
      }

      window.ensureSupaClient = ensureSupaClient;
      ensureSupaClient().catch(err => {
        console.warn("Supabase init failed:", err?.message || err);
      });
    })();
  </script>

  <!-- OPTIONAL GLOBAL (currency/lang only) -->
  <script src="global.js"></script>

  <style>
    .password-box{ position:relative }
    .toggle-password{
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
      cursor:pointer;
      user-select:none;
    }
    .forgot{
      text-align:right;
      font-size:13px;
      color:#ff7a00;
      cursor:pointer;
      margin-top:6px;
    }
  </style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9977276800228616"
     crossorigin="anonymous"></script>
</head>

<body class="login-body">

<div class="login-card">
  <img src="Images/logo.png" class="login-logo">
  <h2 class="login-title">Login to NOVAGAPP</h2>

  <div class="input-box">
    <input id="email" type="email" placeholder="Email">
  </div>

  <div class="input-box password-box">
    <input id="password" type="password" placeholder="Password">
    <span class="toggle-password" onclick="togglePassword()">👁</span>
  </div>

  <div class="forgot" onclick="forgotPassword()">Forgot password?</div>

  <button class="login-btn" onclick="login()">Login</button>

  <div class="or">OR</div>

  <button class="google-btn" onclick="googleLogin()">
    <img src="https://img.icons8.com/color/48/google-logo.png">
    Continue with Google
  </button>

  <div class="signup">
    New to NOVAGAPP?
    <span onclick="location.href='signup.html'">Sign up</span>
  </div>
</div>

<script>
const APP_PUBLIC_ORIGIN = "https://novagapp-mart.onrender.com";

function sanitizeNextPath(raw){
  const value = String(raw || "").trim();
  if(!value) return "";
  if(value.startsWith("//")) return "";

  const normalizePath = (pathValue) => {
    const text = String(pathValue || "").trim();
    if(!text) return "";
    if(!text.startsWith("/")) return "";
    if(/^\/(?:login|signup)\.html(?:[?#]|$)/i.test(text)) return "";
    return text;
  };

  if(/^https?:\/\//i.test(value)){
    try{
      const parsed = new URL(value);
      const allowedOrigins = new Set([
        String(location.origin || "").replace(/\/+$/g, ""),
        String(APP_PUBLIC_ORIGIN || "").replace(/\/+$/g, "")
      ]);
      if(!allowedOrigins.has(String(parsed.origin || "").replace(/\/+$/g, ""))){
        return "";
      }
      return normalizePath(parsed.pathname + parsed.search + parsed.hash);
    }catch(_){
      return "";
    }
  }

  return normalizePath(value);
}

function getDefaultPostLoginPath(){
  return localStorage.getItem("onboarded") === "1" ? "/index.html" : "/onboarding.html";
}

function getRequestedPostLoginPath(){
  const params = new URLSearchParams(location.search);
  const fromQuery = sanitizeNextPath(params.get("next"));
  if(fromQuery){
    return fromQuery;
  }
  try{
    const fromSession = sanitizeNextPath(sessionStorage.getItem("post_login_next"));
    if(fromSession){
      sessionStorage.removeItem("post_login_next");
      return fromSession;
    }
  }catch(_){ }
  return "";
}

function getPostLoginRedirectPath(){
  return getRequestedPostLoginPath() || getDefaultPostLoginPath();
}

function goAfterLogin(path){
  const target = String(path || "").trim() || getDefaultPostLoginPath();
  if(location.protocol === "file:" && target.startsWith("/")){
    location.href = target.slice(1);
    return;
  }
  location.href = target;
}

function buildContestApiCandidates(){
  const out = [];
  const DEFAULT_REMOTE_API_BASE = "https://novagapp-mart.onrender.com";
  const push = (raw) => {
    const val = String(raw || "").trim().replace(/\/+$/g, "");
    if(!val) return;
    if(!/^https?:\/\//i.test(val)) return;
    const isLoopback = /^http:\/\//i.test(val);
    const allowLoopback = location.protocol === "file:";
    if(isLoopback && !allowLoopback) return;
    if(out.includes(val)) return;
    out.push(val);
  };

  const isLocal = location.protocol === "file:";
  const qp = new URLSearchParams(location.search);
  push(DEFAULT_REMOTE_API_BASE);
  push(qp.get("api_base"));
  try{
    push(localStorage.getItem("contest_api_base"));
    push(localStorage.getItem("api_base"));
  }catch(_){ }
  push(window.CONTEST_API_BASE || window.API_BASE || "");
  if(isLocal){
    push("https://novagapp-mart.onrender.com");
    push("https://novagapp-mart.onrender.com");
  }
  if(!out.length && /^https?:\/\//i.test(location.origin)){
    out.push(location.origin.replace(/\/+$/g, ""));
  }
  return out;
}

async function registerContestAccount(user){
  if(!user?.id) return false;
  const payload = {
    user_id: String(user.id || "").trim(),
    user_name: String((user.user_metadata?.full_name || user.user_metadata?.name || user.email || "").split("@")[0] || "").trim(),
    email: String(user.email || "").trim()
  };
  const candidates = buildContestApiCandidates();
  for(const base of candidates){
    try{
      const res = await fetch(base + "/api/contest/account/register", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      if(res.ok) return true;
    }catch(_){ }
  }
  return false;
}

function toTitleCaseWords(text){
  return String(text || "")
    .split(/\s+/)
    .map(part => {
      const token = String(part || "").trim();
      if(!token) return "";
      return token.slice(0, 1).toUpperCase() + token.slice(1).toLowerCase();
    })
    .filter(Boolean)
    .join(" ")
    .slice(0, 60);
}

function deriveIdentity(user){
  const email = String(user?.email || "").trim().toLowerCase();
  const local = String((email.split("@")[0] || "")).trim();
  const words = local.replace(/[._-]+/g, " ").replace(/\d+/g, " ").replace(/\s+/g, " ").trim();
  const displayName = toTitleCaseWords(
    String(user?.user_metadata?.full_name || user?.user_metadata?.name || words || local || "Member")
  ) || "Member";
  const username = String(local || displayName || "member")
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "")
    .slice(0, 24) || "member";
  const emailLocal = local.slice(0, 120);
  const searchTokens = Array.from(new Set(
    `${displayName} ${username} ${emailLocal} ${email}`
      .toLowerCase()
      .replace(/[^a-z0-9@._ -]/g, " ")
      .split(/[\s@._-]+/)
      .map(s => s.trim())
      .filter(Boolean)
  )).slice(0, 40);
  return { email, emailLocal, displayName, username, searchTokens };
}

function extractMissingColumnName(error){
  const text = `${error?.message || ""} ${error?.details || ""}`;
  const pgMatch = text.match(/column\s+\"?([a-zA-Z0-9_.]+)\"?\s+does not exist/i);
  if(pgMatch && pgMatch[1]){
    return String(pgMatch[1]).split(".").pop().toLowerCase();
  }
  const quoted = text.match(/'([a-zA-Z0-9_]+)'/);
  if(quoted && quoted[1]){
    return String(quoted[1]).toLowerCase();
  }
  return "";
}

function isAuthOrRlsWriteError(error){
  const code = String(error?.code || "").trim();
  const status = Number(error?.status || 0);
  const text = `${error?.message || ""} ${error?.details || ""}`.toLowerCase();
  return (
    code === "42501" ||
    status === 401 ||
    status === 403 ||
    text.includes("row-level security")
  );
}

async function upsertProfileRow(supa, user, identity){
  if(!user?.id) return false;
  let hasSessionForUser = false;
  try{
    const { data } = await supa.auth.getSession();
    hasSessionForUser = Boolean(
      data?.session?.access_token &&
      data?.session?.user?.id &&
      data.session.user.id === user.id
    );
  }catch(_){ }
  if(!hasSessionForUser){
    return false;
  }

  let row = {
    user_id: user.id,
    email: identity.email || user.email || "",
    email_local: identity.emailLocal || "",
    username: identity.username || "member",
    full_name: identity.displayName || "Member",
    display_name: identity.displayName || "Member",
    search_tokens: identity.searchTokens || []
  };
  const required = new Set(["user_id"]);
  for(let attempt = 0; attempt < 8; attempt += 1){
    const { error } = await supa
      .from("users")
      .upsert(row, { onConflict: "user_id" });
    if(!error){
      return true;
    }
    if(isAuthOrRlsWriteError(error)){
      return false;
    }
    const missing = extractMissingColumnName(error);
    if(missing && Object.prototype.hasOwnProperty.call(row, missing) && !required.has(missing)){
      delete row[missing];
      continue;
    }
    throw error;
  }
  return false;
}

async function syncAccountIdentity(user, identity){
  if(!user?.id) return false;
  const payload = {
    user_id: user.id,
    email: identity?.email || user.email || "",
    username: identity?.username || "",
    full_name: identity?.displayName || "",
    display_name: identity?.displayName || ""
  };
  const candidates = buildContestApiCandidates();
  for(const base of candidates){
    try{
      const res = await fetch(base + "/api/account/sync", {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      if(res.ok) return true;
    }catch(_){ }
  }
  return false;
}

/* 👁 TOGGLE PASSWORD */
function togglePassword(){
  const p = document.getElementById("password");
  p.type = p.type === "password" ? "text" : "password";
}

/* 🔐 EMAIL LOGIN */
async function login(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(err){
    alert("Supabase config missing. Start server on port 3000 or check public-config.js");
    return;
  }

  const email = document.getElementById("email").value.trim();
  const password = document.getElementById("password").value;

  if(!email || !password){
    alert("Email & password required");
    return;
  }

  const { error } = await supa.auth.signInWithPassword({
    email, password
  });

  if(error){
    const msg = String(error.message || "").toLowerCase();
    if(msg.includes("invalid login credentials")){
      alert("Invalid email or password. Check password, or use Forgot password.");
      return;
    }
    if(msg.includes("email not confirmed")){
      alert("Please verify your email first, then login.");
      return;
    }
    alert(error.message || "Login failed. Please try again.");
    return;
  }

  try{
    const { data:userData } = await supa.auth.getUser();
    const user = userData?.user || null;
    if(user){
      const identity = deriveIdentity(user);
      let profileSynced = false;
      try{
        profileSynced = await syncAccountIdentity(user, identity);
      }catch(_){ }
      if(!profileSynced){
        try{
          await upsertProfileRow(supa, user, identity);
        }catch(profileErr){
          console.warn("profile sync warning", profileErr);
        }
      }
      await registerContestAccount(user);
    }
  }catch(_){ }

  goAfterLogin(getPostLoginRedirectPath());
}

/* 🔐 GOOGLE LOGIN */
async function googleLogin(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(err){
    alert("Supabase config missing. Start server on port 3000 or check public-config.js");
    return;
  }

  const nextPath = getPostLoginRedirectPath();
  try{
    sessionStorage.setItem("post_login_next", nextPath);
  }catch(_){ }

  await supa.auth.signInWithOAuth({
    provider:"google",
    options:{
      redirectTo: APP_PUBLIC_ORIGIN + "/login.html?next=" + encodeURIComponent(nextPath)
    }
  });
}

/* 🔁 FORGOT PASSWORD */
async function forgotPassword(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(err){
    alert("Supabase config missing. Start server on port 3000 or check public-config.js");
    return;
  }

  const email = document.getElementById("email").value.trim();
  if(!email){
    alert("Enter email first");
    return;
  }

  const { error } = await supa.auth.resetPasswordForEmail(email,{
    redirectTo: APP_PUBLIC_ORIGIN + "/reset-password.html"
  });

  if(error){
    alert(error.message);
  }else{
    alert("Password reset email sent");
  }
}

(async function autoContinueIfSignedIn(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(_){
    return;
  }
  let sessionUser = null;
  try{
    const { data } = await supa.auth.getSession();
    sessionUser = data?.session?.user || null;
  }catch(_){
    sessionUser = null;
  }
  if(!sessionUser){
    return;
  }
  const identity = deriveIdentity(sessionUser);
  let profileSynced = false;
  try{
    profileSynced = await syncAccountIdentity(sessionUser, identity);
  }catch(_){ }
  if(!profileSynced){
    try{
      await upsertProfileRow(supa, sessionUser, identity);
    }catch(_){ }
  }
  try{
    await registerContestAccount(sessionUser);
  }catch(_){ }
  goAfterLogin(getPostLoginRedirectPath());
})();
</script>

</body>
</html>
