
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, viewport-fit=cover">
<title>Ride - NovaGapp Mart</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="global.js"></script>
<script src="public-config.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap">
<style>
:root{
  --brand:#ff6a00;
  --brand-dark:#db5600;
  --ink:#10131d;
  --ink-soft:#3a4358;
  --muted:#6b7284;
  --line:#d9e0ee;
  --surface:#f4f6fb;
  --panel:#ffffff;
  --ok:#0f9f50;
  --bad:#c62828;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:radial-gradient(1200px 600px at 50% -120px,#edf2ff 0%,#f6f8fc 45%,#f1f4fb 100%);
  color:var(--ink);
  font-family:"Manrope",sans-serif;
}
.hide{display:none!important}

#rideView{position:fixed;inset:0;background:#fff}
#rideMap{position:absolute;inset:0;z-index:1}
#rideView::after{
  content:"";
  position:absolute;
  left:0;right:0;bottom:56px;
  height:220px;
  background:linear-gradient(180deg,rgba(255,255,255,0) 0%,rgba(13,18,32,.75) 100%);
  pointer-events:none;
  z-index:3;
}

.top-search{
  position:absolute;
  left:12px;
  right:12px;
  top:14px;
  z-index:22;
  display:flex;
  gap:8px;
  background:rgba(255,255,255,.96);
  border:1px solid rgba(210,220,240,.95);
  border-radius:16px;
  padding:8px;
  box-shadow:0 14px 32px rgba(15,23,42,.18);
  backdrop-filter:blur(6px);
}
.top-search input{
  flex:1;
  border:none;
  outline:none;
  font-size:14px;
  font-weight:600;
  color:#111827;
  background:transparent;
}
.top-search button{
  border:none;
  border-radius:11px;
  background:#0f172a;
  color:#fff;
  padding:10px 13px;
  font-weight:800;
  letter-spacing:.01em;
  cursor:pointer;
}
.float-loc{
  position:absolute;
  right:12px;
  top:76px;
  z-index:22;
  border:none;
  border-radius:999px;
  background:#fff;
  padding:10px 13px;
  font-weight:700;
  color:#0f172a;
  box-shadow:0 10px 24px rgba(15,23,42,.22);
  cursor:pointer;
}

.sheet{
  position:absolute;
  left:0;
  right:0;
  bottom:58px;
  z-index:25;
  background:rgba(255,255,255,.98);
  border-top:1px solid #dde3ef;
  border-radius:24px 24px 0 0;
  box-shadow:0 -14px 30px rgba(15,23,42,.2);
  max-height:56vh;
  overflow:auto;
  padding:14px;
}
.panel{display:block}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

.input,select,textarea{
  width:100%;
  padding:12px 13px;
  border:1px solid #d5deed;
  border-radius:12px;
  font-size:14px;
  font-family:"Manrope",sans-serif;
  background:#fff;
  color:#111827;
}
.input:focus,select:focus,textarea:focus{
  outline:none;
  border-color:#ff9a53;
  box-shadow:0 0 0 3px rgba(255,106,0,.16);
}

.btn{
  border:none;
  border-radius:11px;
  padding:11px 13px;
  font-weight:800;
  letter-spacing:.01em;
  cursor:pointer;
  transition:transform .16s ease,filter .16s ease,box-shadow .16s ease;
}
.btn:hover{filter:brightness(.98)}
.btn:active{transform:translateY(1px)}
.btn.brand{
  background:linear-gradient(135deg,#ff7a1a 0%,#ff5900 100%);
  color:#fff;
  box-shadow:0 12px 24px rgba(255,106,0,.28);
}
.btn.gray{background:#334155;color:#fff}
.btn.bad{background:#c62828;color:#fff}
.btn.ok{background:#0f9f50;color:#fff}
.btn.full{width:100%}

.muted{font-size:12px;color:var(--muted);font-weight:500}
.badge{
  display:inline-block;
  padding:5px 10px;
  border-radius:999px;
  font-size:11px;
  background:#eaf2ff;
  color:#1e3a8a;
  font-weight:800;
}

.vehicle-list{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-top:10px}
.vehicle-card{
  border:1px solid #dae2f0;
  border-radius:14px;
  padding:11px;
  cursor:pointer;
  background:#fff;
  transition:border-color .16s ease,transform .16s ease,box-shadow .16s ease;
}
.vehicle-card:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(15,23,42,.1)}
.vehicle-card.active{
  border-color:var(--brand);
  background:linear-gradient(180deg,#fff8f2 0%,#fff 100%);
  box-shadow:0 10px 22px rgba(255,106,0,.15);
}

.matching{display:flex;gap:10px;align-items:center}
.dot{width:10px;height:10px;border-radius:99px;background:var(--brand);animation:p 1.2s infinite}
@keyframes p{
  0%{transform:scale(1)}
  60%{transform:scale(2);opacity:.25}
  100%{transform:scale(1)}
}

.driver{
  display:grid;
  grid-template-columns:58px 1fr auto;
  gap:10px;
  align-items:center;
  background:#f7f9fe;
  border:1px solid #dfe6f2;
  border-radius:14px;
  padding:10px;
}
.driver img{width:58px;height:58px;border-radius:999px;object-fit:cover;background:#ffe4d5}
.status-line{margin-top:6px}

#foodView,#agentView{
  position:fixed;
  inset:0;
  background:linear-gradient(180deg,#f5f8ff 0%,#f2f4fa 100%);
  padding:12px 12px 78px 12px;
  overflow:auto;
}
.block{
  background:rgba(255,255,255,.96);
  border:1px solid #dce3f1;
  border-radius:16px;
  padding:14px;
  box-shadow:0 8px 22px rgba(15,23,42,.08);
}
#foodView .block:first-child,
#agentView .block:first-child{
  background:linear-gradient(145deg,#ffffff 0%,#f8fbff 60%,#f2f7ff 100%);
}

.list-card{
  border:1px solid #dde6f3;
  border-radius:14px;
  padding:11px;
  background:#fff;
  margin-bottom:9px;
  box-shadow:0 6px 16px rgba(15,23,42,.06);
}
.list-title{font-size:14px;font-weight:800;color:#0f172a}
.list-sub{font-size:12px;color:#64748b;margin-top:4px}
.price{font-weight:800;color:#111827}
.qty-btn{
  border:none;
  border-radius:8px;
  padding:6px 11px;
  background:#111827;
  color:#fff;
  cursor:pointer;
  font-weight:700;
}
.status-chip{
  display:inline-block;
  padding:4px 9px;
  border-radius:999px;
  background:#edf2ff;
  color:#1e40af;
  font-size:11px;
  font-weight:800;
}

.bottom-nav{
  position:fixed;
  left:0;
  right:0;
  bottom:0;
  background:rgba(255,255,255,.98);
  border-top:1px solid #d9e2f0;
  backdrop-filter:blur(6px);
  display:grid;
  grid-template-columns:repeat(5,minmax(0,1fr));
  z-index:60;
}
.nav-item{
  border:none;
  background:transparent;
  padding:9px 4px 10px;
  font-size:11px;
  color:#4b5568;
  font-weight:700;
  cursor:pointer;
  text-align:center;
}
.nav-item.active{
  color:var(--brand);
  font-weight:800;
}

.suggest-popup{
  position:fixed;
  z-index:120;
  background:#fff;
  border:1px solid #d8e1ef;
  border-radius:12px;
  box-shadow:0 14px 28px rgba(0,0,0,.18);
  max-height:220px;
  overflow:auto;
}
.suggest-item{
  width:100%;
  border:none;
  text-align:left;
  background:#fff;
  padding:10px;
  font-size:13px;
  color:#0f172a;
  cursor:pointer;
  border-bottom:1px solid #edf2f8;
  font-family:"Manrope",sans-serif;
}
.suggest-item:last-child{border-bottom:none}
.suggest-item:hover{background:#f8fafc}

@media (max-width:900px){
  .sheet{max-height:62vh}
}
@media (max-width:680px){
  .vehicle-list{grid-template-columns:1fr}
  .driver{grid-template-columns:54px 1fr}
  .driver .badge{grid-column:2}
}
</style>
</head>
<body>
<div id="rideView">
  <div id="rideMap"></div>
  <div class="top-search">
    <input id="whereToInput" placeholder="Search destination, chowk, village, landmark">
    <button id="whereSetBtn" type="button">Search</button>
  </div>
  <button class="float-loc" id="locBtn" type="button">Live GPS</button>

  <div class="sheet">
    <div id="idlePanel" class="panel">
      <div class="row" style="justify-content:space-between">
        <b>Book a Ride</b>
        <span class="badge" id="gpsBadge">GPS: detecting...</span>
      </div>
      <div class="row" style="margin-top:8px">
        <input id="pickupInput" class="input" placeholder="Pickup location">
        <input id="dropInput" class="input" placeholder="Drop location">
      </div>
      <div class="row" style="margin-top:8px">
        <input id="pickupLandmarkInput" class="input" placeholder="Pickup landmark / village (e.g. Temple Chowk)">
        <input id="dropLandmarkInput" class="input" placeholder="Drop landmark / village (e.g. School gate)">
      </div>
      <div class="muted" style="margin-top:6px">Use local landmark names (chowk, mandir, school gate) for exact pickup and drop in small cities.</div>
      <div id="routeMeta" class="muted" style="margin-top:8px">Set destination to see fare and ETA.</div>
      <div id="vehicleList" class="vehicle-list"></div>
      <div class="row" style="margin-top:8px">
        <select id="paymentMethod">
          <option value="cash">Cash</option>
          <option value="online">Pay Online</option>
        </select>
      </div>
      <button id="confirmRideBtn" class="btn brand full" style="margin-top:8px">Confirm Ride</button>
    </div>

    <div id="matchingPanel" class="panel hide">
      <div class="matching"><div class="dot"></div><b>Finding nearby drivers...</b></div>
      <div id="matchingText" class="muted status-line">Searching in 3km...</div>
      <button id="cancelMatchingBtn" class="btn bad full" style="margin-top:10px">Cancel Search</button>
    </div>

    <div id="confirmedPanel" class="panel hide">
      <div class="driver">
        <img id="driverPhoto" src="Images/no-image.jpg" alt="Driver">
        <div>
          <div><b id="driverName">Assigned Driver</b></div>
          <div id="driverMeta" class="muted">Rating 4.8 | Vehicle</div>
        </div>
        <div class="badge" id="driverEta">ETA -</div>
      </div>
      <div id="confirmedStatus" class="muted status-line">Status: accepted</div>
      <div id="driverPhone" class="muted status-line">Phone: -</div>
      <a id="callDriverBtn" class="btn gray full" href="#" style="display:block;text-align:center;text-decoration:none;margin-top:8px">Call Driver</a>
      <div class="row" style="margin-top:8px">
        <input id="otpInput" class="input" placeholder="Enter start OTP">
        <button id="verifyOtpBtn" class="btn ok">Start Ride</button>
      </div>
      <button id="cancelAfterAcceptBtn" class="btn bad full" style="margin-top:8px">Cancel Ride</button>
    </div>

    <div id="tripPanel" class="panel hide">
      <span class="badge">Ride Started</span>
      <div id="remainText" class="muted status-line">Distance remaining: -</div>
      <div id="tripEtaText" class="muted status-line">ETA: -</div>
      <button id="sosBtn" class="btn bad full" style="margin-top:8px">Emergency SOS</button>
      <button id="checkCompleteBtn" class="btn brand full" style="margin-top:8px">Check Ride Completion</button>
    </div>

    <div id="donePanel" class="panel hide">
      <b>Ride Complete</b>
      <div class="row" style="justify-content:space-between;margin-top:8px"><span>Ride Fare</span><b id="fareOut">INR 0.00</b></div>
      <div class="row" style="justify-content:space-between;margin-top:4px"><span>Driver Earning</span><b id="driverOut">INR 0.00</b></div>
      <div class="row" style="justify-content:space-between;margin-top:4px"><span>Total Payable</span><b id="totalOut">INR 0.00</b></div>
      <div class="row" style="margin-top:8px">
        <select id="rateInput">
          <option value="5">Rate 5</option>
          <option value="4">Rate 4</option>
          <option value="3">Rate 3</option>
          <option value="2">Rate 2</option>
          <option value="1">Rate 1</option>
        </select>
        <input id="tipInput" class="input" placeholder="Tip amount">
      </div>
      <button id="bookAgainBtn" class="btn brand full" style="margin-top:8px">Book Again</button>
    </div>
  </div>
</div>

<section id="foodView" class="hide">
  <div class="block">
    <div class="row" style="justify-content:space-between">
      <b>Food / Grocery</b>
      <div class="row">
        <button id="foodTypeFoodBtn" class="btn gray" type="button">Food</button>
        <button id="foodTypeGroceryBtn" class="btn gray" type="button">Grocery</button>
      </div>
    </div>
    <div class="muted" id="foodLocationNote" style="margin-top:6px">Fetching nearby stores in 5km based on your live location...</div>
    <div id="foodList" style="margin-top:10px"></div>
  </div>

  <div class="block" style="margin-top:10px">
    <div class="row" style="justify-content:space-between">
      <b id="foodMenuTitle">Menu</b>
      <span class="badge" id="foodCartCount">0 item</span>
    </div>
    <div id="foodMenuList" style="margin-top:10px"></div>
    <div class="row" style="margin-top:8px">
      <input id="foodAddressInput" class="input" placeholder="Delivery address">
      <select id="foodPaymentMethod">
        <option value="cash">Cash on delivery</option>
        <option value="online">Pay online</option>
      </select>
    </div>
    <textarea id="foodNoteInput" class="input" style="margin-top:8px;min-height:70px" placeholder="Order note (optional)"></textarea>
    <div id="foodCartSummary" class="muted" style="margin-top:8px">Cart is empty.</div>
    <button id="foodCheckoutBtn" class="btn brand full" style="margin-top:8px" type="button">Place Order</button>
  </div>

  <div class="block" style="margin-top:10px">
    <div class="row" style="justify-content:space-between">
      <b>My Orders</b>
      <button id="foodOrdersRefreshBtn" class="btn gray" type="button">Refresh</button>
    </div>
    <div id="foodOrdersList" style="margin-top:10px"></div>
  </div>
</section>

<section id="agentView" class="hide">
  <div class="block">
    <div class="row" style="justify-content:space-between">
      <b>Book Agent</b>
      <button id="agentRefreshBtn" class="btn gray" type="button">Refresh</button>
    </div>
    <div id="agentCategoryGrid" class="vehicle-list" style="grid-template-columns:repeat(2,minmax(0,1fr));margin-top:10px"></div>
    <div class="muted" id="agentLocationNote" style="margin-top:8px">Showing available agents in 5km.</div>
    <div id="agentList" style="margin-top:10px"></div>
  </div>

  <div class="block" style="margin-top:10px">
    <b id="agentBookingTitle">Booking</b>
    <div class="row" style="margin-top:8px">
      <input id="agentDateInput" class="input" type="date">
      <input id="agentTimeInput" class="input" type="time">
    </div>
    <div class="row" style="margin-top:8px">
      <input id="agentHoursInput" class="input" type="number" min="1" max="12" value="1" placeholder="Hours">
      <select id="agentPaymentMethod">
        <option value="cash">Pay after service</option>
        <option value="online">Pay online</option>
      </select>
    </div>
    <input id="agentAddressInput" class="input" style="margin-top:8px" placeholder="Service address">
    <textarea id="agentNoteInput" class="input" style="margin-top:8px;min-height:70px" placeholder="Describe issue / landmark"></textarea>
    <div id="agentEstimateText" class="muted" style="margin-top:8px">Select an agent to see estimate.</div>
    <button id="agentBookBtn" class="btn brand full" style="margin-top:8px" type="button">Book Agent</button>
  </div>

  <div class="block" style="margin-top:10px">
    <div class="row" style="justify-content:space-between">
      <b>My Bookings</b>
      <button id="agentBookingsRefreshBtn" class="btn gray" type="button">Refresh</button>
    </div>
    <div id="agentBookingsList" style="margin-top:10px"></div>
  </div>
</section>

<nav class="bottom-nav">
  <button class="nav-item" data-nav="home">Home</button>
  <button class="nav-item active" data-nav="ride">Ride</button>
  <button class="nav-item" data-nav="food">Food/Grocery</button>
  <button class="nav-item" data-nav="agent">Agent</button>
  <button class="nav-item" data-nav="account">F-Account</button>
</nav>

<script>
const supa = window.supa || window.novaCreateSupabaseClient();
const RIDE_STATE_KEY = "nova_ride_state_v3";
const PRICING = {
  bike: { label: "Bike", base: 30, perKm: 8, perMin: 1.5, speed: 28 },
  auto: { label: "Auto", base: 45, perKm: 11, perMin: 2, speed: 24 },
  car: { label: "Car", base: 70, perKm: 15, perMin: 2.8, speed: 30 }
};

const state = {
  me: null,
  vehicle: "auto",
  pickupLat: null,
  pickupLng: null,
  dropLat: null,
  dropLng: null,
  pickupText: "",
  dropText: "",
  pickupLandmark: "",
  dropLandmark: "",
  distanceKm: 0,
  durationMin: 0,
  fare: 0,
  phase: "idle",
  requestId: "",
  trackTimer: null,
  watchId: null,
  lastReverseAt: 0,
  lastNearbyAt: 0,
  matchSecond: 0,
  matchAttempt: 1,
  lastRematchAt: 0,
  gpsLastFixAt: 0,
  gpsFailCount: 0,
  gpsRefreshTimer: null,
  driverUserId: "",
  driverLat: null,
  driverLng: null
};

const foodState = {
  type: "food",
  listings: [],
  selectedListing: null,
  menuItems: [],
  cart: [],
  orders: []
};

const agentState = {
  categories: [
    "electrician",
    "plumber",
    "ac_repair",
    "carpenter",
    "mechanic",
    "painter",
    "cleaning"
  ],
  activeCategory: "electrician",
  agents: [],
  selectedAgent: null,
  bookings: []
};


let map = null;
let pickupMarker = null;
let dropMarker = null;
let routeLine = null;
let nearbyLayer = null;
let driverMarker = null;
let driverGuideLine = null;
let suggestPopup = null;
let suggestSeq = 0;
let suggestDebounceTimer = null;
let pickupResolveSeq = 0;
let rideRealtimeChannel = null;
let driverLocationRealtimeChannel = null;

function money(v){ return "INR " + Number(v || 0).toFixed(2); }
function roundMoney(v){
  const n = Number(v);
  if(!Number.isFinite(n)) return 0;
  return Math.round(n * 100) / 100;
}
function haversineKm(lat1, lon1, lat2, lon2){
  const toRad = d => d * Math.PI / 180;
  const R = 6371;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
}

function rideStatusPublic(statusRaw){
  const s = String(statusRaw || "").trim().toLowerCase();
  if(s === "arriving") return "arrived";
  if(s === "on_trip") return "started";
  return s;
}

function rideStatusLabel(statusRaw){
  const s = rideStatusPublic(statusRaw);
  if(!s) return "unknown";
  if(s === "searching") return "searching";
  if(s === "accepted") return "accepted";
  if(s === "arrived") return "arrived at pickup";
  if(s === "started") return "ride started";
  if(s === "completed") return "completed";
  if(s === "cancelled") return "cancelled";
  return s;
}

function isRideArrived(statusRaw){
  return rideStatusPublic(statusRaw) === "arrived";
}

function isRideStarted(statusRaw){
  return rideStatusPublic(statusRaw) === "started";
}

function apiBases(){
  const out = [];
  const push = (value) => {
    const clean = String(value || "").trim().replace(/\/+$/g, "");
    if(!clean || !/^https?:\/\//i.test(clean)) return;
    if(!out.includes(clean)) out.push(clean);
  };
  push(window.CONTEST_API_BASE || window.API_BASE || "");
  try{
    push(localStorage.getItem("contest_api_base"));
    push(localStorage.getItem("api_base"));
  }catch(_){ }
  if(/^https?:\/\//i.test(location.origin || "")) push(location.origin);
  push("https://novagapp-mart.onrender.com");
  return out;
}

async function apiGet(path){
  for(const base of apiBases()){
    try{
      const res = await fetch(base + path, { cache: "no-store" });
      const json = await res.json().catch(() => null);
      if(res.ok && json?.ok) return json;
    }catch(_){ }
  }
  return null;
}

async function apiPost(path, body){
  for(const base of apiBases()){
    try{
      const res = await fetch(base + path, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      const json = await res.json().catch(() => null);
      if(res.ok && json?.ok) return json;
    }catch(_){ }
  }
  return null;
}
function setPhase(next){
  state.phase = next;
  document.getElementById("idlePanel").classList.toggle("hide", next !== "idle");
  document.getElementById("matchingPanel").classList.toggle("hide", next !== "matching");
  document.getElementById("confirmedPanel").classList.toggle("hide", next !== "confirmed");
  document.getElementById("tripPanel").classList.toggle("hide", next !== "trip");
  document.getElementById("donePanel").classList.toggle("hide", next !== "done");
}

function saveState(){
  try{
    const hasDraft = Boolean(
      state.pickupText || state.dropText || state.pickupLandmark || state.dropLandmark ||
      (state.pickupLat != null && state.pickupLng != null) ||
      (state.dropLat != null && state.dropLng != null)
    );
    if(!state.requestId && !hasDraft){
      localStorage.removeItem(RIDE_STATE_KEY);
      return;
    }
    localStorage.setItem(RIDE_STATE_KEY, JSON.stringify({
      requestId: state.requestId,
      phase: state.phase,
      vehicle: state.vehicle,
      pickupLat: state.pickupLat,
      pickupLng: state.pickupLng,
      dropLat: state.dropLat,
      dropLng: state.dropLng,
      pickupText: state.pickupText,
      dropText: state.dropText,
      pickupLandmark: state.pickupLandmark,
      dropLandmark: state.dropLandmark,
      distanceKm: state.distanceKm,
      durationMin: state.durationMin,
      fare: state.fare,
      savedAt: Date.now()
    }));
  }catch(_){ }
}

function clearState(){
  try{ localStorage.removeItem(RIDE_STATE_KEY); }catch(_){ }
}

function loadState(){
  try{
    const raw = localStorage.getItem(RIDE_STATE_KEY);
    if(!raw) return null;
    const json = JSON.parse(raw);
    if(!json || typeof json !== "object") return null;
    return json;
  }catch(_){
    return null;
  }
}

async function ensureMe(){
  if(state.me) return state.me;
  const { data } = await supa.auth.getSession();
  state.me = data?.session?.user || null;
  if(!state.me){
    location.href = "login.html";
    return null;
  }
  return state.me;
}

function initMap(){
  if(map) return;
  map = L.map("rideMap", { zoomControl: true }).setView([18.5204, 73.8567], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);
  nearbyLayer = L.layerGroup().addTo(map);
  map.on("click", (e) => {
    const lat = Number(e.latlng?.lat);
    const lng = Number(e.latlng?.lng);
    if(!Number.isFinite(lat) || !Number.isFinite(lng)) return;
    setDrop(lat, lng, true).catch(() => {});
  });
}

function setPickupMarker(){
  if(!map || state.pickupLat == null || state.pickupLng == null) return;
  const p = [state.pickupLat, state.pickupLng];
  if(!pickupMarker){
    pickupMarker = L.marker(p, { draggable: true }).addTo(map).bindPopup("Pickup");
    pickupMarker.on("dragend", () => {
      const pos = pickupMarker.getLatLng();
      state.pickupMode = "manual";
      setPickup(Number(pos.lat), Number(pos.lng), false).catch(() => {});
    });
  }else{
    pickupMarker.setLatLng(p);
  }
}

function setDropMarker(){
  if(!map || state.dropLat == null || state.dropLng == null) return;
  const d = [state.dropLat, state.dropLng];
  if(!dropMarker){
    dropMarker = L.marker(d, { draggable: true }).addTo(map).bindPopup("Drop");
    dropMarker.on("dragend", () => {
      const pos = dropMarker.getLatLng();
      setDrop(Number(pos.lat), Number(pos.lng), true).catch(() => {});
    });
  }else{
    dropMarker.setLatLng(d);
  }
}

function updateDriverMarker(){
  if(!map || state.driverLat == null || state.driverLng == null) return;
  const p = [state.driverLat, state.driverLng];
  if(!driverMarker) driverMarker = L.circleMarker(p, { radius: 7, color: "#dc2626", fillOpacity: 1 }).addTo(map);
  else driverMarker.setLatLng(p);
}

function clearDriverGuide(){
  if(map && driverGuideLine){
    map.removeLayer(driverGuideLine);
    driverGuideLine = null;
  }
}

async function reverseGeocode(lat, lng){
  try{
    const url = new URL("https://nominatim.openstreetmap.org/reverse");
    url.searchParams.set("format", "jsonv2");
    url.searchParams.set("addressdetails", "1");
    url.searchParams.set("zoom", "18");
    url.searchParams.set("lat", String(lat));
    url.searchParams.set("lon", String(lng));
    const res = await fetch(url.toString(), {
      cache: "no-store",
      headers: {
        "Accept": "application/json",
        "Accept-Language": "en-IN,en;q=0.9"
      }
    });
    if(res.ok){
      const json = await res.json().catch(() => null);
      const a = json?.address || {};
      const name = buildPlaceName([
        a.road || a.pedestrian || a.footway || a.path || a.neighbourhood || a.suburb || a.hamlet || "",
        a.city || a.town || a.village || a.municipality || a.county || "",
        a.state_district || a.state || "",
        a.postcode || ""
      ]) || String(json?.display_name || "").slice(0, 140);
      if(name) return name;
    }
  }catch(_){ }
  return "Current location";
}

async function geocode(text){
  const q = String(text || "").trim();
  if(!q) return null;
  const fast = await searchLandmarkSuggestions(q, 1);
  if(fast.length){
    const first = fast[0];
    return {
      lat: Number(first.lat),
      lng: Number(first.lng),
      name: String(first.name || q).slice(0, 120)
    };
  }
  try{
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(q)}`;
    const res = await fetch(url, { cache: "no-store" });
    const rows = await res.json().catch(() => []);
    const first = Array.isArray(rows) ? rows[0] : null;
    const lat = Number(first?.lat);
    const lng = Number(first?.lon);
    if(Number.isFinite(lat) && Number.isFinite(lng)){
      return { lat, lng, name: String(first?.display_name || q).slice(0, 120) };
    }
  }catch(_){ }
  return null;
}

function buildPlaceName(parts){
  return parts.map((item) => String(item || "").trim()).filter(Boolean).join(", ").slice(0, 140);
}

function normalizeSuggestion(name, lat, lng){
  const la = Number(lat);
  const ln = Number(lng);
  const nm = String(name || "").trim();
  if(!nm || !Number.isFinite(la) || !Number.isFinite(ln)) return null;
  return { name: nm.slice(0, 140), lat: la, lng: ln };
}

function dedupeSuggestions(list){
  const out = [];
  const seen = new Set();
  (Array.isArray(list) ? list : []).forEach((item) => {
    const row = normalizeSuggestion(item?.name, item?.lat, item?.lng);
    if(!row) return;
    const key = `${row.name.toLowerCase()}|${row.lat.toFixed(6)}|${row.lng.toFixed(6)}`;
    if(seen.has(key)) return;
    seen.add(key);
    out.push(row);
  });
  return out;
}

async function searchLandmarkSuggestions(query, limitCount){
  const q = String(query || "").trim();
  const limit = Math.max(1, Math.min(8, Number(limitCount || 6)));
  if(q.length < 2) return [];
  const merged = [];
  try{
    const nom = new URL("https://nominatim.openstreetmap.org/search");
    nom.searchParams.set("format", "jsonv2");
    nom.searchParams.set("addressdetails", "1");
    nom.searchParams.set("limit", String(limit));
    nom.searchParams.set("countrycodes", "in");
    nom.searchParams.set("q", q);
    if(Number.isFinite(state.liveLat) && Number.isFinite(state.liveLng)){
      const lat = Number(state.liveLat);
      const lng = Number(state.liveLng);
      const dLat = 0.35;
      const dLng = 0.35;
      nom.searchParams.set("viewbox", `${lng - dLng},${lat + dLat},${lng + dLng},${lat - dLat}`);
      nom.searchParams.set("bounded", "0");
    }
    const res = await fetch(nom.toString(), {
      cache: "no-store",
      headers: {
        "Accept": "application/json",
        "Accept-Language": "en-IN,en;q=0.9"
      }
    });
    if(res.ok){
      const rows = await res.json().catch(() => []);
      (Array.isArray(rows) ? rows : []).forEach((row) => {
        const a = row?.address || {};
        const name = buildPlaceName([
          a.road || a.neighbourhood || a.suburb || a.hamlet || a.allotments || "",
          a.city || a.town || a.village || a.municipality || a.county || "",
          a.state_district || a.state || "",
          a.postcode || ""
        ]) || String(row?.display_name || "").slice(0, 140);
        const item = normalizeSuggestion(name, row?.lat, row?.lon);
        if(item) merged.push(item);
      });
    }
  }catch(_){ }
  return dedupeSuggestions(merged).slice(0, limit);
}

function estimateFare(vehicleType){
  const cfg = PRICING[vehicleType] || PRICING.auto;
  if(state.distanceKm <= 0 || state.durationMin <= 0) return null;
  const fare = cfg.base + (state.distanceKm * cfg.perKm) + (state.durationMin * cfg.perMin);
  const eta = Math.max(2, Math.round(state.durationMin * 1.15));
  return { fare, eta };
}

function renderVehicleList(){
  const box = document.getElementById("vehicleList");
  box.innerHTML = "";
  Object.keys(PRICING).forEach((key) => {
    const est = estimateFare(key);
    const card = document.createElement("div");
    card.className = "vehicle-card" + (state.vehicle === key ? " active" : "");
    card.innerHTML = `
      <div><b>${PRICING[key].label}</b></div>
      <div class="muted">ETA ${est ? est.eta : "-"} min</div>
      <div style="margin-top:4px"><b>${est ? money(est.fare) : "Set drop"}</b></div>
    `;
    card.onclick = () => {
      state.vehicle = key;
      const e = estimateFare(key);
      if(e) state.fare = e.fare;
      renderVehicleList();
    };
    box.appendChild(card);
  });
}

async function loadRouteAndFare(){
  if(state.pickupLat == null || state.pickupLng == null || state.dropLat == null || state.dropLng == null){
    document.getElementById("routeMeta").textContent = "Set destination to see fare and ETA.";
    renderVehicleList();
    return;
  }
  let distanceKm = 0;
  let durationMin = 0;
  let geo = null;
  try{
    const url = `https://router.project-osrm.org/route/v1/driving/${state.pickupLng},${state.pickupLat};${state.dropLng},${state.dropLat}?overview=full&geometries=geojson`;
    const res = await fetch(url, { cache: "no-store" });
    const json = await res.json().catch(() => null);
    const route = json?.routes?.[0];
    distanceKm = Number(route?.distance || 0) / 1000;
    durationMin = Number(route?.duration || 0) / 60;
    geo = route?.geometry?.coordinates || null;
  }catch(_){ }
  if(!Number.isFinite(distanceKm) || distanceKm <= 0){
    distanceKm = haversineKm(state.pickupLat, state.pickupLng, state.dropLat, state.dropLng);
  }
  if(!Number.isFinite(durationMin) || durationMin <= 0){
    durationMin = Math.max((distanceKm / PRICING[state.vehicle].speed) * 60, 3);
  }
  state.distanceKm = distanceKm;
  state.durationMin = durationMin;

  if(map){
    if(routeLine){ map.removeLayer(routeLine); routeLine = null; }
    if(Array.isArray(geo) && geo.length > 1){
      const latlngs = geo.map((c) => [Number(c[1]), Number(c[0])]).filter((p) => Number.isFinite(p[0]) && Number.isFinite(p[1]));
      if(latlngs.length > 1) routeLine = L.polyline(latlngs, { color: "#1d4ed8", weight: 5 }).addTo(map);
    }else{
      routeLine = L.polyline([[state.pickupLat, state.pickupLng], [state.dropLat, state.dropLng]], { color: "#1d4ed8", weight: 5 }).addTo(map);
    }
    map.fitBounds([[state.pickupLat, state.pickupLng], [state.dropLat, state.dropLng]], { padding: [24, 24] });
  }

  const est = estimateFare(state.vehicle);
  if(est) state.fare = est.fare;
  document.getElementById("routeMeta").textContent = `Distance ${distanceKm.toFixed(1)} km | Duration ${Math.round(durationMin)} min | Fare ${est ? money(est.fare) : "-"}`;
  renderVehicleList();
}

const RECENT_DEST_KEY = "nova_ride_recent_dest_v1";
const REMATCH_INTERVAL_SEC = 10;
const TRACK_INTERVAL_MS = 3000;
const NEARBY_INTERVAL_MS = 15000;
const MAX_RECENT_DEST = 6;
const RIDE_STATE_TTL_MS = 6 * 60 * 60 * 1000;

state.pickupMode = "gps";
state.liveLat = null;
state.liveLng = null;
state.lastGpsAddressAt = 0;

function ensureRideExtrasUI(){
  const top = document.querySelector(".top-search");
  if(top && !document.getElementById("liveAddressLabel")){
    const label = document.createElement("div");
    label.id = "liveAddressLabel";
    label.className = "muted";
    label.style.marginTop = "6px";
    label.style.marginLeft = "2px";
    label.style.marginRight = "2px";
    label.style.background = "rgba(255,255,255,0.92)";
    label.style.padding = "6px 8px";
    label.style.borderRadius = "10px";
    label.textContent = "Current location: detecting...";
    top.insertAdjacentElement("afterend", label);
  }

  const routeMeta = document.getElementById("routeMeta");
  if(routeMeta && !document.getElementById("nearbyInfo")){
    const near = document.createElement("div");
    near.id = "nearbyInfo";
    near.className = "muted";
    near.style.marginTop = "8px";
    near.textContent = "Nearby drivers: checking...";
    routeMeta.parentElement.insertBefore(near, routeMeta);
  }

  const row = document.querySelector("#idlePanel .row[style*='margin-top:8px']");
  if(row && !document.getElementById("recentWrap")){
    const wrap = document.createElement("div");
    wrap.id = "recentWrap";
    wrap.className = "muted";
    wrap.style.marginTop = "8px";
    wrap.innerHTML = "Recent destinations";
    const chips = document.createElement("div");
    chips.id = "recentList";
    chips.style.display = "flex";
    chips.style.gap = "6px";
    chips.style.overflowX = "auto";
    chips.style.marginTop = "5px";
    chips.style.paddingBottom = "2px";
    wrap.appendChild(chips);
    row.insertAdjacentElement("afterend", wrap);
  }

  const matchingText = document.getElementById("matchingText");
  if(matchingText && !document.getElementById("matchingTimer")){
    const timer = document.createElement("div");
    timer.id = "matchingTimer";
    timer.className = "muted status-line";
    timer.textContent = "Elapsed: 0s";
    matchingText.insertAdjacentElement("afterend", timer);
  }
}

function ensureSuggestPopup(){
  if(suggestPopup) return suggestPopup;
  suggestPopup = document.createElement("div");
  suggestPopup.id = "globalSuggestPopup";
  suggestPopup.className = "suggest-popup hide";
  document.body.appendChild(suggestPopup);

  const hideSoon = () => setTimeout(() => hideSuggestPopup(), 120);
  window.addEventListener("scroll", hideSoon, { passive: true });
  window.addEventListener("resize", hideSoon);
  document.addEventListener("click", (event) => {
    if(!suggestPopup || suggestPopup.classList.contains("hide")) return;
    const t = event.target;
    if(t instanceof Element && (t.closest("#globalSuggestPopup") || t.closest("#whereToInput") || t.closest("#dropInput") || t.closest("#pickupInput"))){
      return;
    }
    hideSuggestPopup();
  });
  return suggestPopup;
}

function hideSuggestPopup(){
  const box = ensureSuggestPopup();
  box.classList.add("hide");
  box.innerHTML = "";
  box.style.left = "0px";
  box.style.top = "0px";
  box.style.width = "0px";
}

function showSuggestPopup(inputEl, items, onPick){
  const input = inputEl instanceof HTMLElement ? inputEl : null;
  const list = Array.isArray(items) ? items : [];
  if(!input || !list.length){
    hideSuggestPopup();
    return;
  }
  const box = ensureSuggestPopup();
  box.innerHTML = "";
  const rect = input.getBoundingClientRect();
  box.style.left = `${Math.max(8, rect.left)}px`;
  box.style.top = `${Math.max(8, rect.bottom + 4)}px`;
  box.style.width = `${Math.max(180, rect.width)}px`;
  list.forEach((item) => {
    const row = document.createElement("button");
    row.type = "button";
    row.className = "suggest-item";
    row.textContent = String(item?.name || "").trim().slice(0, 140);
    row.onclick = () => {
      if(typeof onPick === "function"){
        onPick(item);
      }
      hideSuggestPopup();
    };
    box.appendChild(row);
  });
  box.classList.remove("hide");
}

function scheduleLandmarkSuggest(inputId, pickHandler){
  const input = document.getElementById(inputId);
  if(!input) return;
  const query = String(input.value || "").trim();
  if(query.length < 2){
    hideSuggestPopup();
    return;
  }
  clearTimeout(suggestDebounceTimer);
  suggestDebounceTimer = setTimeout(async () => {
    const seq = ++suggestSeq;
    const list = await searchLandmarkSuggestions(query, 7);
    if(seq !== suggestSeq) return;
    showSuggestPopup(input, list, pickHandler);
  }, 220);
}

function loadRecentDestinations(){
  try{
    const raw = localStorage.getItem(RECENT_DEST_KEY);
    if(!raw) return [];
    const list = JSON.parse(raw);
    return Array.isArray(list) ? list : [];
  }catch(_){
    return [];
  }
}

function saveRecentDestination(place){
  const text = String(place?.text || "").trim().slice(0, 140);
  const lat = Number(place?.lat);
  const lng = Number(place?.lng);
  if(!text || !Number.isFinite(lat) || !Number.isFinite(lng)) return;
  const list = loadRecentDestinations();
  const filtered = list.filter((it) => String(it?.text || "").toLowerCase() !== text.toLowerCase());
  filtered.unshift({ text, lat, lng });
  const finalList = filtered.slice(0, MAX_RECENT_DEST);
  try{ localStorage.setItem(RECENT_DEST_KEY, JSON.stringify(finalList)); }catch(_){ }
}

function renderRecentDestinations(){
  const box = document.getElementById("recentList");
  if(!box) return;
  box.innerHTML = "";
  const list = loadRecentDestinations();
  if(!list.length){
    const t = document.createElement("span");
    t.textContent = "No recent destination";
    t.style.fontSize = "11px";
    box.appendChild(t);
    return;
  }
  list.forEach((item) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = String(item?.text || "Recent").slice(0, 45);
    btn.style.border = "1px solid #dce3f0";
    btn.style.borderRadius = "999px";
    btn.style.padding = "6px 10px";
    btn.style.background = "#fff";
    btn.style.whiteSpace = "nowrap";
    btn.style.cursor = "pointer";
    btn.onclick = () => {
      setDrop(Number(item?.lat), Number(item?.lng), false, String(item?.text || ""))
        .then(() => loadRouteAndFare())
        .catch(() => {});
    };
    box.appendChild(btn);
  });
}

function shouldRestoreSavedState(saved){
  const ts = Number(saved?.savedAt || 0);
  return ts > 0 && (Date.now() - ts) <= RIDE_STATE_TTL_MS;
}

function updateLiveAddressLabel(text){
  const label = document.getElementById("liveAddressLabel");
  if(!label) return;
  label.textContent = "Current location: " + (String(text || "").trim() || "detecting...");
}

function setMatchingText(text){
  const el = document.getElementById("matchingText");
  if(el) el.textContent = text;
}

function setMatchingTimerText(text){
  const el = document.getElementById("matchingTimer");
  if(el) el.textContent = text;
}

function setNearbyInfo(text){
  const el = document.getElementById("nearbyInfo");
  if(el) el.textContent = text;
}

function setRideHint(text){
  const msg = String(text || "").trim();
  if(!msg) return;
  const routeMeta = document.getElementById("routeMeta");
  if(routeMeta) routeMeta.textContent = msg;
  setMatchingText(msg);
}

function composePlaceText(baseText, landmarkText){
  const base = String(baseText || "").trim();
  const landmark = String(landmarkText || "").trim();
  if(!base && !landmark) return "Location pin";
  if(!landmark) return base || "Location pin";
  if(!base) return `Landmark: ${landmark}`;
  if(base.toLowerCase().includes(landmark.toLowerCase())) return base;
  return `${base} | Landmark: ${landmark}`;
}

async function ensureConsumerRole(){
  const me = await ensureMe();
  if(!me) return false;
  const roles = await apiGet(`/api/local/roles?user_id=${encodeURIComponent(me.id)}`);
  const hasConsumer = Array.isArray(roles?.roles)
    && roles.roles.some((r) => String(r?.role || "") === "consumer" && String(r?.status || "") === "active");
  if(hasConsumer) return true;
  const displayName = String(me?.user_metadata?.full_name || me?.user_metadata?.name || me?.email || "Consumer").slice(0, 80);
  const enroll = await apiPost("/api/local/role/enroll", {
    user_id: me.id,
    role: "consumer",
    display_name: displayName,
    fee_paid: true,
    payment_ref: "consumer_auto"
  });
  return Boolean(enroll?.ok);
}

async function setPickup(lat, lng, fromGps){
  if(!Number.isFinite(Number(lat)) || !Number.isFinite(Number(lng))) return;
  state.pickupLat = Number(lat);
  state.pickupLng = Number(lng);
  setPickupMarker();

  const now = Date.now();
  const shouldResolve = !state.pickupText || (now - state.lastReverseAt > 9000) || !fromGps;
  if(shouldResolve){
    state.lastReverseAt = now;
    const seq = ++pickupResolveSeq;
    const name = await reverseGeocode(state.pickupLat, state.pickupLng);
    if(seq !== pickupResolveSeq) return;
    if(fromGps && state.pickupMode === "manual") return;
    if(name) state.pickupText = name;
  }

  document.getElementById("pickupInput").value = state.pickupText || "";
  updateLiveAddressLabel(state.pickupText || "detecting...");

  if(map && fromGps && state.phase === "idle"){
    map.setView([state.pickupLat, state.pickupLng], Math.max(15, map.getZoom()));
  }

  if(state.dropLat != null && state.dropLng != null){
    await loadRouteAndFare();
  }

  if(state.phase === "idle"){
    await fetchNearbyDrivers();
  }

  saveState();
}

async function setDrop(lat, lng, fromMap, explicitName){
  if(!Number.isFinite(Number(lat)) || !Number.isFinite(Number(lng))) return;
  state.dropLat = Number(lat);
  state.dropLng = Number(lng);
  setDropMarker();

  let dropName = String(explicitName || "").trim();
  if(!dropName){
    dropName = await reverseGeocode(state.dropLat, state.dropLng);
  }
  state.dropText = String(dropName || "").trim().slice(0, 160);

  const dropInput = document.getElementById("dropInput");
  const whereInput = document.getElementById("whereToInput");
  dropInput.value = state.dropText;
  whereInput.value = state.dropText;

  if(map && fromMap){
    map.fitBounds([[state.pickupLat || state.dropLat, state.pickupLng || state.dropLng], [state.dropLat, state.dropLng]], { padding: [24, 24] });
  }

  if(state.dropText){
    saveRecentDestination({ text: state.dropText, lat: state.dropLat, lng: state.dropLng });
    renderRecentDestinations();
  }

  saveState();
}

function updateGpsBadgeLive(accuracy){
  const badge = document.getElementById("gpsBadge");
  const acc = Number(accuracy);
  const accTxt = Number.isFinite(acc) ? ` (${Math.round(acc)}m)` : "";
  const quality = Number.isFinite(acc) ? (acc <= 40 ? "accurate" : (acc <= 120 ? "ok" : "weak")) : "live";
  badge.textContent = `GPS: ${quality}${accTxt}`;
}

function updateGpsBadgeBlocked(){
  state.gpsFailCount = (Number(state.gpsFailCount || 0) + 1);
  document.getElementById("gpsBadge").textContent = "GPS: permission required";
  updateLiveAddressLabel("permission required");
}

async function applyGpsFix(pos, shouldCenter){
  const lat = Number(pos?.coords?.latitude);
  const lng = Number(pos?.coords?.longitude);
  const acc = Number(pos?.coords?.accuracy);
  if(!Number.isFinite(lat) || !Number.isFinite(lng)) return false;
  state.gpsFailCount = 0;
  state.gpsLastFixAt = Date.now();
  state.liveLat = lat;
  state.liveLng = lng;
  updateGpsBadgeLive(acc);
  if(state.phase === "idle" && state.pickupMode === "gps"){
    await setPickup(lat, lng, true);
  }else if(shouldCenter && map){
    map.setView([lat, lng], Math.max(15, map.getZoom()));
  }
  return true;
}

async function tryApproxLocationFallback(){
  // Avoid random IP-based auto pickup. Force real GPS permission instead.
  document.getElementById("gpsBadge").textContent = "GPS: permission required";
  updateLiveAddressLabel("Allow device location for accurate pickup");
}

async function fetchNearbyDrivers(){
  if(state.pickupLat == null || state.pickupLng == null) return;
  const now = Date.now();
  if(now - state.lastNearbyAt < 2500) return;
  state.lastNearbyAt = now;

  const res = await apiGet(`/api/local/riders/nearby?lat=${encodeURIComponent(String(state.pickupLat))}&lng=${encodeURIComponent(String(state.pickupLng))}&radius_km=3&limit=20`);
  if(!res?.ok){
    setNearbyInfo("Nearby drivers unavailable right now");
    if(nearbyLayer) nearbyLayer.clearLayers();
    return;
  }

  const drivers = Array.isArray(res.drivers) ? res.drivers : [];
  if(nearbyLayer) nearbyLayer.clearLayers();
  drivers.forEach((driver) => {
    const lat = Number(driver?.lat);
    const lng = Number(driver?.lng);
    if(!Number.isFinite(lat) || !Number.isFinite(lng)) return;
    const marker = L.circleMarker([lat, lng], {
      radius: 5,
      color: "#0f766e",
      fillColor: "#14b8a6",
      fillOpacity: 0.85,
      weight: 1
    }).addTo(nearbyLayer);
    const store = String(driver?.store_name || "Nearby driver").trim();
    const distance = Number(driver?.distance_km);
    marker.bindTooltip(Number.isFinite(distance) ? `${store} - ${distance.toFixed(2)} km` : store);
  });
  setNearbyInfo(`${drivers.length} nearby driver(s) in 3 km`);
}

function startNearbyLoop(){
  if(state.nearbyTimer){
    clearInterval(state.nearbyTimer);
    state.nearbyTimer = null;
  }
  state.nearbyTimer = setInterval(() => {
    if(state.phase !== "idle") return;
    fetchNearbyDrivers().catch(() => {});
  }, NEARBY_INTERVAL_MS);
}

function stopNearbyLoop(){
  if(state.nearbyTimer){
    clearInterval(state.nearbyTimer);
    state.nearbyTimer = null;
  }
}

function startGpsWatch(){
  if(!navigator.geolocation){
    document.getElementById("gpsBadge").textContent = "GPS: unsupported";
    updateLiveAddressLabel("unsupported on this device");
    tryApproxLocationFallback().catch(() => {});
    return;
  }

  const requestCurrent = (centerNow) => {
    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        await applyGpsFix(pos, Boolean(centerNow));
      },
      async () => {
        updateGpsBadgeBlocked();
      },
      { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
    );
  };

  if(navigator.permissions?.query){
    navigator.permissions.query({ name: "geolocation" }).then((perm) => {
      if(perm?.state === "denied"){
        updateGpsBadgeBlocked();
      }else{
        requestCurrent(true);
      }
    }).catch(() => requestCurrent(true));
  }else{
    requestCurrent(true);
  }

  if(state.watchId != null){
    navigator.geolocation.clearWatch(state.watchId);
    state.watchId = null;
  }

  state.watchId = navigator.geolocation.watchPosition(
    async (pos) => {
      await applyGpsFix(pos, false);
    },
    async () => {
      updateGpsBadgeBlocked();
    },
    { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
  );

  if(state.gpsRefreshTimer){
    clearInterval(state.gpsRefreshTimer);
    state.gpsRefreshTimer = null;
  }
  state.gpsRefreshTimer = setInterval(() => {
    if(state.phase !== "idle") return;
    const stale = !state.gpsLastFixAt || (Date.now() - state.gpsLastFixAt) > 15000;
    if(!stale) return;
    requestCurrent(false);
  }, 8000);
}

async function focusCurrentLocation(){
  state.pickupMode = "gps";
  if(state.liveLat != null && state.liveLng != null){
    if(map) map.setView([state.liveLat, state.liveLng], Math.max(15, map.getZoom()));
    if(state.phase === "idle"){
      await setPickup(state.liveLat, state.liveLng, true);
    }
    return;
  }

  if(!navigator.geolocation){
    updateGpsBadgeBlocked();
    return;
  }

  navigator.geolocation.getCurrentPosition(
    async (pos) => {
      await applyGpsFix(pos, true);
    },
    async () => {
      updateGpsBadgeBlocked();
    },
    { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
  );
}

function stopGpsWatch(){
  if(state.watchId != null && navigator.geolocation){
    navigator.geolocation.clearWatch(state.watchId);
  }
  state.watchId = null;
  if(state.gpsRefreshTimer){
    clearInterval(state.gpsRefreshTimer);
    state.gpsRefreshTimer = null;
  }
}

async function handleDestinationInput(text){
  const query = String(text || "").trim();
  if(!query) return;
  const found = await geocode(query);
  if(!found){
    setRideHint("Destination not found. Try area + city.");
    return;
  }
  await setDrop(Number(found.lat), Number(found.lng), true, String(found.name || query));
  await loadRouteAndFare();
}

function stopMatchingLoop(){
  if(state.matchTimer){
    clearInterval(state.matchTimer);
    state.matchTimer = null;
  }
}

function stopTrackLoop(){
  if(state.trackTimer){
    clearInterval(state.trackTimer);
    state.trackTimer = null;
  }
}

async function stopRideRealtime(){
  if(!rideRealtimeChannel) return;
  try{
    await supa.removeChannel(rideRealtimeChannel);
  }catch(_){ }
  rideRealtimeChannel = null;
}

async function stopDriverLocationRealtime(){
  if(!driverLocationRealtimeChannel) return;
  try{
    await supa.removeChannel(driverLocationRealtimeChannel);
  }catch(_){ }
  driverLocationRealtimeChannel = null;
}

async function startDriverLocationRealtime(driverUserId){
  const id = String(driverUserId || "").trim();
  if(!id) return;
  if(state.driverUserId === id && driverLocationRealtimeChannel) return;
  await stopDriverLocationRealtime();
  state.driverUserId = id;

  const channelName = `ride-driver-loc-${id}-${Date.now()}`;
  driverLocationRealtimeChannel = supa.channel(channelName);
  driverLocationRealtimeChannel
    .on("postgres_changes", {
      event: "*",
      schema: "public",
      table: "local_rider_locations",
      filter: `user_id=eq.${id}`
    }, (payload) => {
      const row = payload?.new || payload?.record || {};
      const lat = Number(row?.lat);
      const lng = Number(row?.lng);
      if(!Number.isFinite(lat) || !Number.isFinite(lng)) return;
      state.driverLat = lat;
      state.driverLng = lng;
      updateDriverMarker();
      updateDriverGuide();
      if(state.pickupLat != null && state.pickupLng != null){
        const etaKm = haversineKm(lat, lng, state.pickupLat, state.pickupLng);
        const etaMin = Math.max(1, Math.round((etaKm / 24) * 60));
        document.getElementById("driverEta").textContent = `ETA ${etaMin} min`;
      }
      if(state.phase === "trip"){
        updateTripStats();
      }
    })
    .subscribe((status) => {
      if(status === "CHANNEL_ERROR"){
        stopDriverLocationRealtime().catch(() => {});
      }
    });
}

async function startRideRealtime(requestId){
  const reqId = String(requestId || "").trim();
  if(!reqId) return;
  if(rideRealtimeChannel && state.requestId === reqId) return;
  await stopRideRealtime();

  const channelName = `ride-status-${reqId}-${Date.now()}`;
  rideRealtimeChannel = supa.channel(channelName);
  rideRealtimeChannel
    .on("postgres_changes", {
      event: "*",
      schema: "public",
      table: "local_ride_requests",
      filter: `id=eq.${reqId}`
    }, (payload) => {
      const row = payload?.new || payload?.record || {};
      const status = rideStatusPublic(row?.status);
      const driverUserId = String(row?.driver_user_id || "").trim();
      if(driverUserId){
        startDriverLocationRealtime(driverUserId).catch(() => {});
      }
      if(status === "cancelled" || status === "completed"){
        stopDriverLocationRealtime().catch(() => {});
      }
      pollRideTrack().catch(() => {});
    })
    .subscribe((status) => {
      if(status === "CHANNEL_ERROR"){
        stopRideRealtime().catch(() => {});
      }
    });
}

function updateDriverGuide(){
  clearDriverGuide();
  if(!map || state.driverLat == null || state.driverLng == null) return;
  const onTrip = state.phase === "trip";
  const toLat = onTrip ? state.dropLat : state.pickupLat;
  const toLng = onTrip ? state.dropLng : state.pickupLng;
  if(toLat == null || toLng == null) return;
  driverGuideLine = L.polyline([[state.driverLat, state.driverLng], [toLat, toLng]], {
    color: onTrip ? "#16a34a" : "#f97316",
    weight: 4,
    dashArray: onTrip ? undefined : "8,8"
  }).addTo(map);
}

function applyDriverFromTrack(track, status){
  const profile = track?.driver_profile || {};
  const loc = track?.driver_location || {};
  const ride = track?.ride_request || {};
  const publicStatus = rideStatusPublic(status);
  const driverUserId = String(ride?.driver_user_id || "").trim();
  const driverName = String(profile?.name || "Assigned Driver").trim() || "Assigned Driver";
  const image = String(profile?.image_url || "").trim();
  const phone = String(track?.driver_phone || "").trim();

  document.getElementById("driverName").textContent = driverName;
  document.getElementById("driverMeta").textContent = `Vehicle ${String(PRICING[state.vehicle]?.label || state.vehicle).toUpperCase()} | ${rideStatusLabel(publicStatus)}`;
  document.getElementById("confirmedStatus").textContent = `Status: ${rideStatusLabel(publicStatus)}`;
  document.getElementById("driverPhone").textContent = phone ? `Phone: ${phone}` : "Phone: unavailable";
  document.getElementById("driverPhoto").src = image || "Images/no-image.jpg";
  if(driverUserId){
    startDriverLocationRealtime(driverUserId).catch(() => {});
  }

  const callBtn = document.getElementById("callDriverBtn");
  callBtn.href = phone ? `tel:${phone}` : "#";
  callBtn.style.opacity = phone ? "1" : "0.6";

  const dLat = Number(loc?.lat);
  const dLng = Number(loc?.lng);
  if(Number.isFinite(dLat) && Number.isFinite(dLng)){
    state.driverLat = dLat;
    state.driverLng = dLng;
    updateDriverMarker();
    updateDriverGuide();

    if(state.pickupLat != null && state.pickupLng != null){
      const etaKm = haversineKm(dLat, dLng, state.pickupLat, state.pickupLng);
      const etaMin = Math.max(1, Math.round((etaKm / 24) * 60));
      document.getElementById("driverEta").textContent = `ETA ${etaMin} min`;
    }
  }
}

function updateTripStats(){
  let remainKm = 0;
  if(state.driverLat != null && state.driverLng != null && state.dropLat != null && state.dropLng != null){
    remainKm = haversineKm(state.driverLat, state.driverLng, state.dropLat, state.dropLng);
  }else{
    remainKm = Number(state.distanceKm || 0);
  }
  const etaMin = Math.max(1, Math.round((remainKm / 24) * 60));
  document.getElementById("remainText").textContent = `Distance remaining: ${remainKm.toFixed(1)} km`;
  document.getElementById("tripEtaText").textContent = `ETA: ${etaMin} min`;
}

async function rematchRide(){
  if(!state.requestId || state.phase !== "matching") return;
  const me = await ensureMe();
  if(!me) return;
  const rematch = await apiPost("/api/local/rides/rematch", {
    request_id: state.requestId,
    rider_user_id: me.id,
    pickup_lat: state.pickupLat,
    pickup_lng: state.pickupLng
  });
  if(rematch?.ok){
    const offered = Number(rematch?.newly_offered_count || 0);
    setMatchingText(offered > 0 ? `Offered to ${offered} new driver(s)...` : "Still checking next nearest rider...");
  }
}

function startMatchingAndTrackLoops(){
  stopMatchingLoop();
  stopTrackLoop();
  state.matchSecond = 0;
  setMatchingTimerText("Elapsed: 0s");
  state.matchTimer = setInterval(() => {
    state.matchSecond += 1;
    setMatchingTimerText(`Elapsed: ${state.matchSecond}s`);
    if(state.matchSecond % REMATCH_INTERVAL_SEC === 0){
      rematchRide().catch(() => {});
    }
  }, 1000);

  state.trackTimer = setInterval(() => {
    pollRideTrack().catch(() => {});
  }, TRACK_INTERVAL_MS);
}

function startTrackLoopOnly(){
  stopTrackLoop();
  state.trackTimer = setInterval(() => {
    pollRideTrack().catch(() => {});
  }, TRACK_INTERVAL_MS);
}

async function pollRideTrack(){
  if(!state.requestId) return;
  const track = await apiGet(`/api/local/rides/track?request_id=${encodeURIComponent(state.requestId)}`);
  if(!track?.ok) return;
  const rideRow = track?.ride_request || {};
  const status = rideStatusPublic(rideRow?.status);
  const driverUserId = String(rideRow?.driver_user_id || "").trim();
  if(driverUserId){
    state.driverUserId = driverUserId;
    startDriverLocationRealtime(driverUserId).catch(() => {});
  }

  if(status === "searching"){
    if(state.phase !== "matching"){
      setPhase("matching");
      startMatchingAndTrackLoops();
    }
    saveState();
    return;
  }

  if(status === "accepted" || isRideArrived(status)){
    stopMatchingLoop();
    setPhase("confirmed");
    applyDriverFromTrack(track, status);
    saveState();
    return;
  }

  if(isRideStarted(status)){
    stopMatchingLoop();
    setPhase("trip");
    applyDriverFromTrack(track, status);
    updateTripStats();
    saveState();
    return;
  }

  if(status === "completed"){
    stopMatchingLoop();
    stopTrackLoop();
    await stopDriverLocationRealtime();
    await stopRideRealtime();
    setPhase("done");
    await renderRideSummary();
    saveState();
    return;
  }

  if(status === "cancelled" || status === "rejected"){
    stopMatchingLoop();
    stopTrackLoop();
    await stopDriverLocationRealtime();
    await stopRideRealtime();
    await resetRideFlow(true);
  }
}

async function requestRide(){
  const me = await ensureMe();
  if(!me) return;
  state.pickupLandmark = String(document.getElementById("pickupLandmarkInput")?.value || state.pickupLandmark || "").trim().slice(0, 120);
  state.dropLandmark = String(document.getElementById("dropLandmarkInput")?.value || state.dropLandmark || "").trim().slice(0, 120);
  if(state.pickupLat == null || state.pickupLng == null){
    setRideHint("Pickup not detected yet. Tap Current Location.");
    return;
  }
  if(state.dropLat == null || state.dropLng == null){
    setRideHint("Please set destination first.");
    return;
  }

  const roleOk = await ensureConsumerRole();
  if(!roleOk){
    setRideHint("Consumer role setup failed. Retry in few seconds.");
    return;
  }

  const fareRes = await apiPost("/api/local/rides/fare-estimate", {
    pickup_lat: state.pickupLat,
    pickup_lng: state.pickupLng,
    drop_lat: state.dropLat,
    drop_lng: state.dropLng,
    vehicle_type: state.vehicle,
    distance_km: state.distanceKm,
    duration_min: state.durationMin
  });
  if(fareRes?.ok && fareRes?.estimate?.fare_inr){
    state.fare = Number(fareRes.estimate.fare_inr);
  }
  const selectedPayment = String(document.getElementById("paymentMethod")?.value || "cash").trim().toLowerCase();
  let paymentPayload = {
    payment_method: "cash",
    payment_status: "cod",
    payment_order_id: "",
    payment_id: "",
    payment_ref: ""
  };
  if(selectedPayment === "online"){
    try{
      paymentPayload = await handleOnlinePayment(
        "ride",
        state.fare,
        "ride",
        "",
        `Pay ${money(state.fare)} for ${prettyLabel(state.vehicle)} ride`
      );
    }catch(err){
      setRideHint(String(err?.message || "Payment failed"));
      return;
    }
  }

  const req = await apiPost("/api/local/rides/request", {
    user_id: me.id,
    pickup_lat: state.pickupLat,
    pickup_lng: state.pickupLng,
    drop_lat: state.dropLat,
    drop_lng: state.dropLng,
    pickup_text: composePlaceText(state.pickupText || "Pickup", state.pickupLandmark).slice(0, 160),
    drop_text: composePlaceText(state.dropText || "Drop", state.dropLandmark).slice(0, 160),
    vehicle_type: state.vehicle,
    ...paymentPayload,
    fare_inr: state.fare,
    distance_km: state.distanceKm,
    duration_min: state.durationMin
  });

  if(!req?.ok || !req?.ride_request?.id){
    const msg = String(req?.message || req?.error || "Ride request failed");
    setRideHint(msg);
    return;
  }

  state.requestId = String(req.ride_request.id || "").trim();
  setPhase("matching");
  setMatchingText("Searching in 3km...");
  startRideRealtime(state.requestId).catch(() => {});
  startMatchingAndTrackLoops();
  saveState();
}

async function verifyOtp(){
  const me = await ensureMe();
  if(!me || !state.requestId) return;
  const otp = String(document.getElementById("otpInput").value || "").trim();
  if(!otp){
    document.getElementById("confirmedStatus").textContent = "Status: enter OTP first";
    return;
  }
  const out = await apiPost("/api/local/rides/otp/verify", {
    request_id: state.requestId,
    rider_user_id: me.id,
    otp
  });
  if(!out?.ok){
    document.getElementById("confirmedStatus").textContent = "Status: invalid OTP";
    return;
  }
  setPhase("trip");
  updateTripStats();
  saveState();
}

async function cancelRideAsRider(){
  const me = await ensureMe();
  if(!me || !state.requestId) return;
  await apiPost("/api/local/rides/cancel", {
    request_id: state.requestId,
    user_id: me.id,
    by: "rider"
  });
  await resetRideFlow(true);
}

async function renderRideSummary(){
  const tipRaw = Number(document.getElementById("tipInput").value || 0);
  const tip = Number.isFinite(tipRaw) && tipRaw > 0 ? tipRaw : 0;
  const summary = await apiGet(`/api/local/rides/summary?request_id=${encodeURIComponent(state.requestId)}&vehicle_type=${encodeURIComponent(state.vehicle)}&tip_inr=${encodeURIComponent(String(tip))}`);

  let fare = Number(state.fare || 0);
  let driver = Number((fare * 0.9).toFixed(2));
  let total = Number((fare + tip).toFixed(2));

  if(summary?.ok && summary?.summary){
    fare = Number(summary.summary.fare_inr || fare);
    driver = Number(summary.summary.driver_earning_inr || driver);
    total = Number(summary.summary.total_fare_inr || total);
  }

  document.getElementById("fareOut").textContent = money(fare);
  document.getElementById("driverOut").textContent = money(driver);
  document.getElementById("totalOut").textContent = money(total);
}

async function resetRideFlow(keepPickup){
  stopMatchingLoop();
  stopTrackLoop();
  await stopRideRealtime();
  await stopDriverLocationRealtime();

  state.requestId = "";
  state.matchSecond = 0;
  state.driverUserId = "";
  state.driverLat = null;
  state.driverLng = null;

  if(routeLine && map){ map.removeLayer(routeLine); routeLine = null; }
  if(dropMarker && map){ map.removeLayer(dropMarker); dropMarker = null; }
  if(driverMarker && map){ map.removeLayer(driverMarker); driverMarker = null; }
  clearDriverGuide();

  state.dropLat = null;
  state.dropLng = null;
  state.dropText = "";
  state.dropLandmark = "";
  state.distanceKm = 0;
  state.durationMin = 0;
  state.fare = 0;

  document.getElementById("dropInput").value = "";
  document.getElementById("dropLandmarkInput").value = "";
  document.getElementById("whereToInput").value = "";
  document.getElementById("otpInput").value = "";

  if(!keepPickup){
    state.pickupLat = null;
    state.pickupLng = null;
    state.pickupText = "";
    state.pickupLandmark = "";
    document.getElementById("pickupLandmarkInput").value = "";
    if(pickupMarker && map){ map.removeLayer(pickupMarker); pickupMarker = null; }
  }

  setPhase("idle");
  clearState();
  document.getElementById("routeMeta").textContent = "Set destination to see fare and ETA.";
  renderVehicleList();

  if(state.phase === "idle"){
    await fetchNearbyDrivers();
  }
}

let activeView = "ride";
let foodBooted = false;
let agentBooted = false;
let foodOrderTimer = null;
let agentBookingTimer = null;

function prettyLabel(text){
  return String(text || "").replace(/_/g, " ").replace(/\b\w/g, (m) => m.toUpperCase());
}

function calcFoodCartTotal(){
  return roundMoney(foodState.cart.reduce((sum, row) => sum + (Number(row.price_inr || 0) * Number(row.qty || 0)), 0));
}

function calcAgentEstimate(agent, hours){
  const base = Math.max(0, Number(agent?.price_per_visit_inr || 0));
  const perHour = Math.max(0, Number(agent?.per_hour_rate_inr || 0));
  const h = Math.max(1, Math.min(12, Math.round(Number(hours || 1))));
  return roundMoney(base + (perHour * h));
}

async function ensureLocationForServices(){
  if(Number.isFinite(state.pickupLat) && Number.isFinite(state.pickupLng)){
    return {
      lat: state.pickupLat,
      lng: state.pickupLng,
      address: state.pickupText || ""
    };
  }
  await focusCurrentLocation().catch(() => {});
  if(Number.isFinite(state.pickupLat) && Number.isFinite(state.pickupLng)){
    return {
      lat: state.pickupLat,
      lng: state.pickupLng,
      address: state.pickupText || ""
    };
  }
  throw new Error("location_not_available");
}

async function handleOnlinePayment(module, amountInr, referenceType, referenceId, description){
  const me = await ensureMe();
  if(!me) throw new Error("login_required");
  const amount = Math.max(1, roundMoney(amountInr || 0));
  const order = await apiPost("/api/local/payments/order", {
    user_id: me.id,
    module,
    amount_inr: amount,
    reference_type: referenceType || "",
    reference_id: referenceId || ""
  });
  if(!order?.ok || !order?.order?.razorpay_order_id){
    throw new Error(order?.message || order?.error || "payment_order_failed");
  }
  if(typeof window.Razorpay !== "function"){
    throw new Error("razorpay_sdk_missing");
  }
  return await new Promise((resolve, reject) => {
    const rz = new window.Razorpay({
      key: order.order.key_id,
      amount: order.order.amount_paise,
      currency: "INR",
      name: "NovaGapp Local Services",
      description: description || "Service payment",
      order_id: order.order.razorpay_order_id,
      prefill: {
        email: String(me?.email || ""),
        name: String(me?.user_metadata?.full_name || me?.user_metadata?.name || ""),
        contact: String(me?.phone || me?.user_metadata?.phone || "")
      },
      theme: { color: "#ff6a00" },
      handler: async function(resp){
        try{
          const verify = await apiPost("/api/local/payments/verify", {
            user_id: me.id,
            module,
            reference_type: referenceType || "",
            reference_id: referenceId || "",
            razorpay_order_id: resp?.razorpay_order_id,
            razorpay_payment_id: resp?.razorpay_payment_id,
            razorpay_signature: resp?.razorpay_signature
          });
          if(!verify?.ok){
            reject(new Error(verify?.message || verify?.error || "payment_verify_failed"));
            return;
          }
          resolve({
            payment_method: "online",
            payment_status: "captured",
            payment_order_id: String(resp?.razorpay_order_id || ""),
            payment_id: String(resp?.razorpay_payment_id || ""),
            payment_ref: String(resp?.razorpay_payment_id || "")
          });
        }catch(err){
          reject(err);
        }
      },
      modal: {
        ondismiss: () => reject(new Error("payment_cancelled"))
      }
    });
    rz.open();
  });
}

function renderFoodTypeButtons(){
  const foodBtn = document.getElementById("foodTypeFoodBtn");
  const groceryBtn = document.getElementById("foodTypeGroceryBtn");
  if(foodBtn) foodBtn.className = `btn ${foodState.type === "food" ? "brand" : "gray"}`;
  if(groceryBtn) groceryBtn.className = `btn ${foodState.type === "grocery" ? "brand" : "gray"}`;
}

function renderFoodListings(){
  const box = document.getElementById("foodList");
  if(!box) return;
  box.innerHTML = "";
  if(!foodState.listings.length){
    box.innerHTML = `<div class="muted">No ${foodState.type} partners found nearby.</div>`;
    return;
  }
  foodState.listings.forEach((listing) => {
    const div = document.createElement("div");
    div.className = "list-card";
    const active = foodState.selectedListing && String(foodState.selectedListing.id) === String(listing.id);
    const distance = Number(listing?.distance_km || 0);
    div.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="list-title">${String(listing.store_name || "Store")}</div>
          <div class="list-sub">${distance.toFixed(2)} km | ${listing.open_now ? "Open" : "Closed"} | Delivery INR ${Number(listing.delivery_charge_inr || 0).toFixed(2)}</div>
          <div class="list-sub">Min order INR ${Number(listing.minimum_order_inr || 0).toFixed(2)}</div>
        </div>
        <button class="btn ${active ? "brand" : "gray"}" data-food-listing="${String(listing.id)}">${active ? "Selected" : "View"}</button>
      </div>
    `;
    box.appendChild(div);
  });
}

function renderFoodMenu(){
  const title = document.getElementById("foodMenuTitle");
  const box = document.getElementById("foodMenuList");
  if(title){
    title.textContent = foodState.selectedListing
      ? `${String(foodState.selectedListing.store_name || "Store")} menu`
      : "Menu";
  }
  if(!box) return;
  box.innerHTML = "";
  if(!foodState.selectedListing){
    box.innerHTML = `<div class="muted">Select a partner to load menu.</div>`;
    return;
  }
  if(!foodState.menuItems.length){
    box.innerHTML = `<div class="muted">No menu items available right now.</div>`;
    return;
  }
  foodState.menuItems.forEach((item) => {
    const div = document.createElement("div");
    div.className = "list-card";
    const inCart = foodState.cart.find((c) => String(c.id) === String(item.id));
    const qty = Number(inCart?.qty || 0);
    div.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="list-title">${String(item.name || "Item")}</div>
          <div class="list-sub">${String(item.category || "General")}</div>
          <div class="price">INR ${Number(item.price_inr || 0).toFixed(2)}</div>
        </div>
        <div class="row">
          <button class="qty-btn" data-food-dec="${String(item.id)}">-</button>
          <span style="min-width:18px;text-align:center">${qty}</span>
          <button class="qty-btn" data-food-inc="${String(item.id)}">+</button>
        </div>
      </div>
    `;
    box.appendChild(div);
  });
}

function renderFoodCartSummary(){
  const count = foodState.cart.reduce((sum, row) => sum + Number(row.qty || 0), 0);
  const subtotal = calcFoodCartTotal();
  const delivery = Number(foodState.selectedListing?.delivery_charge_inr || 0);
  const total = roundMoney(subtotal + delivery);
  const minOrder = Number(foodState.selectedListing?.minimum_order_inr || 0);
  const countEl = document.getElementById("foodCartCount");
  if(countEl){
    countEl.textContent = `${count} item${count === 1 ? "" : "s"}`;
  }
  const summary = document.getElementById("foodCartSummary");
  if(!summary) return;
  if(!count){
    summary.textContent = "Cart is empty.";
    return;
  }
  summary.textContent = `Subtotal ${money(subtotal)} + Delivery ${money(delivery)} = Total ${money(total)}${minOrder > 0 ? ` | Min order ${money(minOrder)}` : ""}`;
}

function updateFoodAddressPrefill(){
  const input = document.getElementById("foodAddressInput");
  if(!input) return;
  if(String(input.value || "").trim()) return;
  if(state.pickupText){
    input.value = state.pickupText;
  }
}

function mutateCart(item, delta){
  const id = String(item?.id || "");
  if(!id) return;
  const found = foodState.cart.find((row) => String(row.id) === id);
  if(!found && delta > 0){
    foodState.cart.push({
      id,
      name: String(item.name || ""),
      price_inr: Number(item.price_inr || 0),
      image_url: String(item.image_url || ""),
      qty: 1
    });
  }else if(found){
    found.qty = Math.max(0, Number(found.qty || 0) + delta);
    if(found.qty <= 0){
      foodState.cart = foodState.cart.filter((row) => String(row.id) !== id);
    }
  }
  renderFoodMenu();
  renderFoodCartSummary();
}

async function loadFoodListings(){
  const note = document.getElementById("foodLocationNote");
  if(note) note.textContent = "Loading nearby partners...";
  try{
    const ctx = await ensureLocationForServices();
    updateFoodAddressPrefill();
    const res = await apiGet(`/api/local/nearby?type=${encodeURIComponent(foodState.type)}&lat=${encodeURIComponent(String(ctx.lat))}&lng=${encodeURIComponent(String(ctx.lng))}&radius_km=5&limit=40`);
    foodState.listings = Array.isArray(res?.listings) ? res.listings : [];
    if(note){
      note.textContent = `${foodState.listings.length} ${foodState.type} partner(s) found in 5km`;
    }
    renderFoodListings();
    if(foodState.selectedListing){
      const exists = foodState.listings.find((row) => String(row.id) === String(foodState.selectedListing.id));
      if(!exists){
        foodState.selectedListing = null;
        foodState.menuItems = [];
        foodState.cart = [];
      }
    }
    renderFoodMenu();
    renderFoodCartSummary();
  }catch(err){
    if(note) note.textContent = "Location unavailable. Enable GPS for nearby food/grocery.";
    foodState.listings = [];
    renderFoodListings();
    renderFoodMenu();
    renderFoodCartSummary();
  }
}

async function selectFoodListing(listingId){
  const id = String(listingId || "").trim();
  if(!id) return;
  const listing = foodState.listings.find((row) => String(row.id) === id);
  if(!listing) return;
  foodState.selectedListing = listing;
  foodState.cart = [];
  renderFoodListings();
  const menuRes = await apiGet(`/api/local/listings/items?listing_id=${encodeURIComponent(id)}`);
  foodState.menuItems = Array.isArray(menuRes?.items) ? menuRes.items.filter((item) => Number(item?.stock_qty || 0) > 0) : [];
  renderFoodMenu();
  renderFoodCartSummary();
}

function renderFoodOrders(){
  const box = document.getElementById("foodOrdersList");
  if(!box) return;
  box.innerHTML = "";
  if(!foodState.orders.length){
    box.innerHTML = `<div class="muted">No orders yet.</div>`;
    return;
  }
  foodState.orders.forEach((order) => {
    const div = document.createElement("div");
    div.className = "list-card";
    const status = String(order?.status || "placed");
    const items = Array.isArray(order?.item_snapshot) ? order.item_snapshot : [];
    const itemText = items.map((item) => `${item.name} x${item.qty}`).join(", ");
    div.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="list-title">Order ${String(order.id || "").slice(0, 8).toUpperCase()}</div>
          <div class="list-sub">${prettyLabel(String(order.service_type || foodState.type))} | ${money(order.amount_inr || 0)}</div>
          <div class="list-sub">${itemText || "Items not available"}</div>
          <div class="list-sub">${String(order.delivery_address || "")}</div>
        </div>
        <span class="status-chip">${prettyLabel(status)}</span>
      </div>
    `;
    box.appendChild(div);
  });
}

async function loadFoodOrders(){
  const me = await ensureMe();
  if(!me) return;
  const orders = await apiGet(`/api/local/orders/for-buyer?user_id=${encodeURIComponent(me.id)}`);
  foodState.orders = Array.isArray(orders?.orders) ? orders.orders : [];
  renderFoodOrders();
}

async function checkoutFoodOrder(){
  const me = await ensureMe();
  if(!me) return;
  if(!foodState.selectedListing){
    alert("Select a restaurant/store first.");
    return;
  }
  if(!foodState.cart.length){
    alert("Cart is empty.");
    return;
  }
  const roleOk = await ensureConsumerRole();
  if(!roleOk){
    alert("Consumer role activation failed.");
    return;
  }
  const address = String(document.getElementById("foodAddressInput")?.value || "").trim();
  if(!address){
    alert("Delivery address required.");
    return;
  }
  const note = String(document.getElementById("foodNoteInput")?.value || "").trim().slice(0, 300);
  const paymentMethod = String(document.getElementById("foodPaymentMethod")?.value || "cash").trim();
  const subtotal = calcFoodCartTotal();
  const delivery = Number(foodState.selectedListing?.delivery_charge_inr || 0);
  const total = roundMoney(subtotal + delivery);
  const minOrder = Number(foodState.selectedListing?.minimum_order_inr || 0);
  if(total < minOrder){
    alert(`Minimum order is ${money(minOrder)}.`);
    return;
  }
  let paymentPayload = {
    payment_method: "cash",
    payment_status: "cod",
    payment_order_id: "",
    payment_id: "",
    payment_ref: ""
  };
  if(paymentMethod === "online"){
    try{
      paymentPayload = await handleOnlinePayment(
        foodState.type,
        total,
        "order",
        "",
        `Pay ${money(total)} for ${prettyLabel(foodState.type)} order`
      );
    }catch(err){
      alert(String(err?.message || "Payment failed"));
      return;
    }
  }
  const items = foodState.cart.map((row) => ({
    item_id: row.id,
    name: row.name,
    qty: row.qty,
    price_inr: row.price_inr,
    image_url: row.image_url
  }));
  const out = await apiPost("/api/local/orders/create", {
    user_id: me.id,
    listing_id: foodState.selectedListing.id,
    service_type: foodState.type,
    amount_inr: total,
    items,
    delivery_address: address,
    note,
    ...paymentPayload
  });
  if(!out?.ok){
    alert(String(out?.message || out?.error || "Order failed"));
    return;
  }
  foodState.cart = [];
  renderFoodMenu();
  renderFoodCartSummary();
  await loadFoodOrders();
  alert("Order placed successfully.");
}

function renderAgentCategories(){
  const box = document.getElementById("agentCategoryGrid");
  if(!box) return;
  box.innerHTML = "";
  agentState.categories.forEach((cat) => {
    const b = document.createElement("button");
    b.type = "button";
    b.className = `btn ${agentState.activeCategory === cat ? "brand" : "gray"}`;
    b.textContent = prettyLabel(cat);
    b.dataset.agentCat = cat;
    box.appendChild(b);
  });
}

function renderAgentList(){
  const box = document.getElementById("agentList");
  if(!box) return;
  box.innerHTML = "";
  if(!agentState.agents.length){
    box.innerHTML = `<div class="muted">No agent available in selected category.</div>`;
    return;
  }
  agentState.agents.forEach((agent) => {
    const selected = agentState.selectedAgent && String(agentState.selectedAgent.id) === String(agent.id);
    const hours = Number(document.getElementById("agentHoursInput")?.value || 1);
    const estimate = calcAgentEstimate(agent, hours);
    const div = document.createElement("div");
    div.className = "list-card";
    div.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="list-title">${String(agent.title || "Agent")}</div>
          <div class="list-sub">${prettyLabel(agent.service_category)} | ${Number(agent.distance_km || 0).toFixed(2)} km</div>
          <div class="list-sub">Rating ${Number(agent.rating || 0).toFixed(1)} (${Number(agent.rating_count || 0)}) | Exp ${Number(agent.experience_years || 0)} yr</div>
          <div class="list-sub">Visit ${money(agent.price_per_visit_inr || 0)} + ${money(agent.per_hour_rate_inr || 0)}/hr</div>
          <div class="price">Est. ${money(estimate)}</div>
        </div>
        <button class="btn ${selected ? "brand" : "gray"}" data-agent-id="${String(agent.id)}">${selected ? "Selected" : "Select"}</button>
      </div>
    `;
    box.appendChild(div);
  });
}

function renderAgentEstimate(){
  const text = document.getElementById("agentEstimateText");
  if(!text) return;
  if(!agentState.selectedAgent){
    text.textContent = "Select an agent to see estimate.";
    return;
  }
  const hours = Math.max(1, Math.min(12, Math.round(Number(document.getElementById("agentHoursInput")?.value || 1))));
  const estimate = calcAgentEstimate(agentState.selectedAgent, hours);
  text.textContent = `Estimated price: ${money(estimate)} for ${hours} hour(s).`;
}

async function loadNearbyAgents(){
  const note = document.getElementById("agentLocationNote");
  if(note) note.textContent = "Loading nearby agents...";
  try{
    const ctx = await ensureLocationForServices();
    const out = await apiGet(`/api/local/agents/nearby?service_category=${encodeURIComponent(agentState.activeCategory)}&lat=${encodeURIComponent(String(ctx.lat))}&lng=${encodeURIComponent(String(ctx.lng))}&radius_km=5`);
    agentState.agents = Array.isArray(out?.agents) ? out.agents : [];
    if(note){
      note.textContent = `${agentState.agents.length} ${prettyLabel(agentState.activeCategory)} agent(s) found in 5km`;
    }
  }catch(_){
    agentState.agents = [];
    if(note) note.textContent = "Location unavailable. Enable GPS for nearby agents.";
  }
  if(agentState.selectedAgent){
    const fresh = agentState.agents.find((row) => String(row.id) === String(agentState.selectedAgent.id));
    if(!fresh) agentState.selectedAgent = null;
  }
  renderAgentCategories();
  renderAgentList();
  renderAgentEstimate();
}

function renderAgentBookings(){
  const box = document.getElementById("agentBookingsList");
  if(!box) return;
  box.innerHTML = "";
  if(!agentState.bookings.length){
    box.innerHTML = `<div class="muted">No bookings yet.</div>`;
    return;
  }
  agentState.bookings.forEach((booking) => {
    const div = document.createElement("div");
    div.className = "list-card";
    div.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="list-title">Booking ${String(booking.id || "").slice(0, 8).toUpperCase()}</div>
          <div class="list-sub">${String(booking.service_address || "")}</div>
          <div class="list-sub">Scheduled: ${booking.scheduled_at ? new Date(booking.scheduled_at).toLocaleString() : "-"}</div>
          <div class="list-sub">Estimated: ${money(booking.estimated_price_inr || 0)}</div>
        </div>
        <span class="status-chip">${prettyLabel(booking.status || "requested")}</span>
      </div>
    `;
    box.appendChild(div);
  });
}

async function loadAgentBookings(){
  const me = await ensureMe();
  if(!me) return;
  const out = await apiGet(`/api/local/agent/bookings?user_id=${encodeURIComponent(me.id)}&side=customer`);
  agentState.bookings = Array.isArray(out?.bookings) ? out.bookings : [];
  renderAgentBookings();
}

async function bookAgentNow(){
  const me = await ensureMe();
  if(!me) return;
  const roleOk = await ensureConsumerRole();
  if(!roleOk){
    alert("Consumer role activation failed.");
    return;
  }
  if(!agentState.selectedAgent){
    alert("Select an agent first.");
    return;
  }
  const serviceDate = String(document.getElementById("agentDateInput")?.value || "").trim();
  const serviceTime = String(document.getElementById("agentTimeInput")?.value || "").trim();
  if(!serviceDate || !serviceTime){
    alert("Choose date and time.");
    return;
  }
  const hours = Math.max(1, Math.min(12, Math.round(Number(document.getElementById("agentHoursInput")?.value || 1))));
  const address = String(document.getElementById("agentAddressInput")?.value || "").trim();
  if(!address){
    alert("Service address required.");
    return;
  }
  const note = String(document.getElementById("agentNoteInput")?.value || "").trim().slice(0, 300);
  const paymentMethod = String(document.getElementById("agentPaymentMethod")?.value || "cash").trim();
  const estimate = calcAgentEstimate(agentState.selectedAgent, hours);
  let paymentPayload = {
    payment_method: "cash",
    payment_status: "cod",
    payment_order_id: "",
    payment_id: "",
    payment_ref: ""
  };
  if(paymentMethod === "online"){
    try{
      paymentPayload = await handleOnlinePayment("agent", estimate, "service_booking", "", `Pay ${money(estimate)} for agent booking`);
    }catch(err){
      alert(String(err?.message || "Payment failed"));
      return;
    }
  }
  const out = await apiPost("/api/local/agents/book", {
    customer_user_id: me.id,
    agent_id: agentState.selectedAgent.id,
    service_address: address,
    note,
    service_date: serviceDate,
    service_time: serviceTime,
    hours_booked: hours,
    estimated_price_inr: estimate,
    ...paymentPayload
  });
  if(!out?.ok){
    alert(String(out?.message || out?.error || "Booking failed"));
    return;
  }
  await loadAgentBookings();
  alert("Agent booking created.");
}

function bindFoodEvents(){
  document.getElementById("foodTypeFoodBtn")?.addEventListener("click", async () => {
    foodState.type = "food";
    foodState.selectedListing = null;
    foodState.menuItems = [];
    foodState.cart = [];
    renderFoodTypeButtons();
    renderFoodMenu();
    renderFoodCartSummary();
    await loadFoodListings();
  });
  document.getElementById("foodTypeGroceryBtn")?.addEventListener("click", async () => {
    foodState.type = "grocery";
    foodState.selectedListing = null;
    foodState.menuItems = [];
    foodState.cart = [];
    renderFoodTypeButtons();
    renderFoodMenu();
    renderFoodCartSummary();
    await loadFoodListings();
  });
  document.getElementById("foodList")?.addEventListener("click", (event) => {
    const btn = event.target.closest("button[data-food-listing]");
    if(!btn) return;
    selectFoodListing(String(btn.dataset.foodListing || "")).catch(() => {});
  });
  document.getElementById("foodMenuList")?.addEventListener("click", (event) => {
    const incBtn = event.target.closest("button[data-food-inc]");
    if(incBtn){
      const id = String(incBtn.dataset.foodInc || "");
      const item = foodState.menuItems.find((row) => String(row.id) === id);
      if(item) mutateCart(item, 1);
      return;
    }
    const decBtn = event.target.closest("button[data-food-dec]");
    if(decBtn){
      const id = String(decBtn.dataset.foodDec || "");
      const item = foodState.menuItems.find((row) => String(row.id) === id);
      if(item) mutateCart(item, -1);
    }
  });
  document.getElementById("foodCheckoutBtn")?.addEventListener("click", () => {
    checkoutFoodOrder().catch(() => {});
  });
  document.getElementById("foodOrdersRefreshBtn")?.addEventListener("click", () => {
    loadFoodOrders().catch(() => {});
  });
}

function bindAgentEvents(){
  document.getElementById("agentCategoryGrid")?.addEventListener("click", (event) => {
    const btn = event.target.closest("button[data-agent-cat]");
    if(!btn) return;
    const cat = String(btn.dataset.agentCat || "");
    if(!cat || !agentState.categories.includes(cat)) return;
    agentState.activeCategory = cat;
    agentState.selectedAgent = null;
    loadNearbyAgents().catch(() => {});
  });
  document.getElementById("agentList")?.addEventListener("click", (event) => {
    const btn = event.target.closest("button[data-agent-id]");
    if(!btn) return;
    const id = String(btn.dataset.agentId || "");
    const found = agentState.agents.find((row) => String(row.id) === id);
    if(!found) return;
    agentState.selectedAgent = found;
    renderAgentList();
    renderAgentEstimate();
    const title = document.getElementById("agentBookingTitle");
    if(title) title.textContent = `Booking with ${String(found.title || "Agent")}`;
  });
  document.getElementById("agentHoursInput")?.addEventListener("input", () => {
    renderAgentEstimate();
    renderAgentList();
  });
  document.getElementById("agentBookBtn")?.addEventListener("click", () => {
    bookAgentNow().catch(() => {});
  });
  document.getElementById("agentRefreshBtn")?.addEventListener("click", () => {
    loadNearbyAgents().catch(() => {});
  });
  document.getElementById("agentBookingsRefreshBtn")?.addEventListener("click", () => {
    loadAgentBookings().catch(() => {});
  });
}

async function bootFoodModule(){
  if(!foodBooted){
    foodBooted = true;
    bindFoodEvents();
    renderFoodTypeButtons();
    renderFoodMenu();
    renderFoodCartSummary();
  }
  updateFoodAddressPrefill();
  await loadFoodListings();
  await loadFoodOrders();
}

async function bootAgentModule(){
  if(!agentBooted){
    agentBooted = true;
    bindAgentEvents();
    renderAgentCategories();
    renderAgentList();
    renderAgentEstimate();
    const now = new Date();
    const dateInput = document.getElementById("agentDateInput");
    const timeInput = document.getElementById("agentTimeInput");
    if(dateInput && !dateInput.value){
      dateInput.value = now.toISOString().slice(0, 10);
    }
    if(timeInput && !timeInput.value){
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      timeInput.value = `${hh}:${mm}`;
    }
  }
  const addressInput = document.getElementById("agentAddressInput");
  if(addressInput && !String(addressInput.value || "").trim() && state.pickupText){
    addressInput.value = state.pickupText;
  }
  await loadNearbyAgents();
  await loadAgentBookings();
}

function startFoodTimer(){
  if(foodOrderTimer) clearInterval(foodOrderTimer);
  foodOrderTimer = setInterval(() => {
    if(activeView !== "food") return;
    loadFoodOrders().catch(() => {});
  }, 12000);
}

function stopFoodTimer(){
  if(foodOrderTimer){
    clearInterval(foodOrderTimer);
    foodOrderTimer = null;
  }
}

function startAgentTimer(){
  if(agentBookingTimer) clearInterval(agentBookingTimer);
  agentBookingTimer = setInterval(() => {
    if(activeView !== "agent") return;
    loadAgentBookings().catch(() => {});
  }, 12000);
}

function stopAgentTimer(){
  if(agentBookingTimer){
    clearInterval(agentBookingTimer);
    agentBookingTimer = null;
  }
}

function setActiveView(view){
  activeView = view;
  const ride = document.getElementById("rideView");
  const food = document.getElementById("foodView");
  const agent = document.getElementById("agentView");

  ride.classList.toggle("hide", view !== "ride");
  food.classList.toggle("hide", view !== "food");
  agent.classList.toggle("hide", view !== "agent");

  document.querySelectorAll(".nav-item").forEach((btn) => {
    btn.classList.toggle("active", btn.getAttribute("data-nav") === view);
  });

  if(view === "ride" && map){
    setTimeout(() => map.invalidateSize(), 80);
  }
  if(view === "food"){
    bootFoodModule().catch(() => {});
    startFoodTimer();
    stopAgentTimer();
  }else if(view === "agent"){
    bootAgentModule().catch(() => {});
    startAgentTimer();
    stopFoodTimer();
  }else{
    stopFoodTimer();
    stopAgentTimer();
  }
}

async function restoreStateIfPresent(){
  const saved = loadState();
  if(!saved || !shouldRestoreSavedState(saved)) return;

  state.requestId = String(saved.requestId || "").trim();
  state.phase = String(saved.phase || "idle").trim() || "idle";
  state.vehicle = PRICING[saved.vehicle] ? saved.vehicle : "auto";
  state.pickupLat = Number.isFinite(Number(saved.pickupLat)) ? Number(saved.pickupLat) : null;
  state.pickupLng = Number.isFinite(Number(saved.pickupLng)) ? Number(saved.pickupLng) : null;
  state.dropLat = Number.isFinite(Number(saved.dropLat)) ? Number(saved.dropLat) : null;
  state.dropLng = Number.isFinite(Number(saved.dropLng)) ? Number(saved.dropLng) : null;
  state.pickupText = String(saved.pickupText || "").trim().slice(0, 160);
  state.dropText = String(saved.dropText || "").trim().slice(0, 160);
  state.pickupLandmark = String(saved.pickupLandmark || "").trim().slice(0, 120);
  state.dropLandmark = String(saved.dropLandmark || "").trim().slice(0, 120);
  state.distanceKm = Number(saved.distanceKm || 0);
  state.durationMin = Number(saved.durationMin || 0);
  state.fare = Number(saved.fare || 0);

  document.getElementById("pickupInput").value = state.pickupText;
  document.getElementById("dropInput").value = state.dropText;
  document.getElementById("pickupLandmarkInput").value = state.pickupLandmark;
  document.getElementById("dropLandmarkInput").value = state.dropLandmark;
  document.getElementById("whereToInput").value = state.dropText;

  if(state.pickupLat != null && state.pickupLng != null){
    setPickupMarker();
    updateLiveAddressLabel(state.pickupText || "detecting...");
  }
  if(state.dropLat != null && state.dropLng != null){
    setDropMarker();
    await loadRouteAndFare();
  }

  if(state.requestId && ["matching", "confirmed", "trip", "done"].includes(state.phase)){
    setPhase(state.phase === "done" ? "matching" : state.phase);
    startRideRealtime(state.requestId).catch(() => {});
    if(state.phase === "matching"){
      startMatchingAndTrackLoops();
    }else{
      stopMatchingLoop();
      startTrackLoopOnly();
    }
    await pollRideTrack();
  }else{
    setPhase("idle");
  }
}

function bindRideEvents(){
  const whereInput = document.getElementById("whereToInput");
  const dropInput = document.getElementById("dropInput");
  const pickupInput = document.getElementById("pickupInput");
  const pickupLandmarkInput = document.getElementById("pickupLandmarkInput");
  const dropLandmarkInput = document.getElementById("dropLandmarkInput");

  document.getElementById("whereSetBtn").onclick = () => {
    handleDestinationInput(whereInput.value).catch(() => {});
  };

  whereInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      hideSuggestPopup();
      handleDestinationInput(whereInput.value).catch(() => {});
    }
  });
  whereInput.addEventListener("input", () => {
    scheduleLandmarkSuggest("whereToInput", async (place) => {
      await setDrop(Number(place?.lat), Number(place?.lng), true, String(place?.name || ""));
      await loadRouteAndFare();
    });
  });
  whereInput.addEventListener("focus", () => {
    scheduleLandmarkSuggest("whereToInput", async (place) => {
      await setDrop(Number(place?.lat), Number(place?.lng), true, String(place?.name || ""));
      await loadRouteAndFare();
    });
  });

  dropInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      hideSuggestPopup();
      handleDestinationInput(dropInput.value).catch(() => {});
    }
  });
  dropInput.addEventListener("input", () => {
    scheduleLandmarkSuggest("dropInput", async (place) => {
      await setDrop(Number(place?.lat), Number(place?.lng), true, String(place?.name || ""));
      await loadRouteAndFare();
    });
  });
  dropInput.addEventListener("focus", () => {
    scheduleLandmarkSuggest("dropInput", async (place) => {
      await setDrop(Number(place?.lat), Number(place?.lng), true, String(place?.name || ""));
      await loadRouteAndFare();
    });
  });

  pickupInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      hideSuggestPopup();
      const q = String(pickupInput.value || "").trim();
      if(!q) return;
      geocode(q).then(async (found) => {
        if(!found) return;
        state.pickupMode = "manual";
        state.pickupText = String(found.name || q).slice(0, 160);
        await setPickup(Number(found.lat), Number(found.lng), false);
      }).catch(() => {});
    }
  });
  pickupInput.addEventListener("input", () => {
    scheduleLandmarkSuggest("pickupInput", async (place) => {
      state.pickupMode = "manual";
      state.pickupText = String(place?.name || "").slice(0, 160);
      await setPickup(Number(place?.lat), Number(place?.lng), false);
    });
  });
  pickupInput.addEventListener("focus", () => {
    scheduleLandmarkSuggest("pickupInput", async (place) => {
      state.pickupMode = "manual";
      state.pickupText = String(place?.name || "").slice(0, 160);
      await setPickup(Number(place?.lat), Number(place?.lng), false);
    });
  });

  pickupLandmarkInput.addEventListener("input", () => {
    state.pickupLandmark = String(pickupLandmarkInput.value || "").trim().slice(0, 120);
    saveState();
  });
  dropLandmarkInput.addEventListener("input", () => {
    state.dropLandmark = String(dropLandmarkInput.value || "").trim().slice(0, 120);
    saveState();
  });

  document.getElementById("locBtn").onclick = () => {
    focusCurrentLocation().catch(() => {});
  };

  document.getElementById("confirmRideBtn").onclick = () => {
    requestRide().catch(() => {});
  };

  document.getElementById("cancelMatchingBtn").onclick = () => {
    cancelRideAsRider().catch(() => {});
  };

  document.getElementById("cancelAfterAcceptBtn").onclick = () => {
    cancelRideAsRider().catch(() => {});
  };

  document.getElementById("verifyOtpBtn").onclick = () => {
    verifyOtp().catch(() => {});
  };

  document.getElementById("checkCompleteBtn").onclick = () => {
    pollRideTrack().catch(() => {});
  };

  document.getElementById("sosBtn").onclick = () => {
    location.href = "tel:112";
  };

  document.getElementById("tipInput").addEventListener("change", () => {
    if(state.phase === "done"){
      renderRideSummary().catch(() => {});
    }
  });

  document.getElementById("bookAgainBtn").onclick = () => {
    resetRideFlow(true).catch(() => {});
  };

  document.querySelectorAll(".nav-item").forEach((btn) => {
    btn.addEventListener("click", () => {
      const nav = String(btn.getAttribute("data-nav") || "").trim();
      if(nav === "home"){
        location.href = "index.html";
        return;
      }
      if(nav === "account"){
        location.href = "F-account.html";
        return;
      }
      if(nav === "food"){
        setActiveView("food");
        return;
      }
      if(nav === "agent"){
        setActiveView("agent");
        return;
      }
      setActiveView("ride");
    });
  });
}

async function bootRidePage(){
  ensureRideExtrasUI();
  ensureSuggestPopup();
  renderRecentDestinations();
  initMap();
  bindRideEvents();
  renderVehicleList();
  setPhase("idle");
  setActiveView("ride");

  await ensureMe();
  await restoreStateIfPresent();

  startGpsWatch();
  startNearbyLoop();

  if(state.phase === "idle"){
    await fetchNearbyDrivers();
  }

  window.addEventListener("beforeunload", () => {
    stopGpsWatch();
    stopNearbyLoop();
    stopFoodTimer();
    stopAgentTimer();
    stopRideRealtime().catch(() => {});
    stopDriverLocationRealtime().catch(() => {});
    hideSuggestPopup();
  });

  document.addEventListener("visibilitychange", () => {
    if(document.visibilityState === "visible"){
      startGpsWatch();
      if(state.requestId){
        startRideRealtime(state.requestId).catch(() => {});
        pollRideTrack().catch(() => {});
      }
      if(state.phase === "idle"){
        fetchNearbyDrivers().catch(() => {});
      }
      if(activeView === "food"){
        loadFoodListings().catch(() => {});
        loadFoodOrders().catch(() => {});
      }else if(activeView === "agent"){
        loadNearbyAgents().catch(() => {});
        loadAgentBookings().catch(() => {});
      }
    }
  });
}

bootRidePage().catch((err) => {
  console.error("ride_boot_failed", err);
});
</script>
</body>
</html>
