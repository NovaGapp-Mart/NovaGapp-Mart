<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Checkout - NOVAGAPP</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">

<!-- SUPABASE SDK -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="public-config.js"></script>

<!-- GLOBAL -->
<script src="global.js"></script>

<style>
body{
  margin:0;
  font-family: Arial, sans-serif;
  background:#f2f2f2;
}
.header{
  background:#fff;
  padding:12px;
  display:flex;
  align-items:center;
  gap:10px;
  font-size:18px;
  font-weight:bold;
  border-bottom:1px solid #ddd;
}
.section{
  background:#fff;
  margin:10px;
  padding:15px;
  border-radius:8px;
}
.step{
  display:flex;
  gap:10px;
  font-size:14px;
  margin-bottom:10px;
}
.step span{
  width:22px;
  height:22px;
  border-radius:50%;
  background:#2874f0;
  color:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:12px;
}
.input{
  width:100%;
  padding:10px;
  margin:8px 0;
  border:1px solid #ccc;
  border-radius:5px;
}
.input-row{
  display:flex;
  gap:8px;
}
.input-row .input{
  flex:1;
}
.cart-item{
  display:flex;
  gap:10px;
  margin-bottom:12px;
}
.cart-item img{
  width:70px;
  height:70px;
  border-radius:6px;
  object-fit:cover;
}
.cart-title{
  font-size:15px;
  font-weight:bold;
}
.cart-price{
  color:#388e3c;
}
.summary div{
  display:flex;
  justify-content:space-between;
  margin:6px 0;
}
.total{
  font-size:18px;
  font-weight:bold;
}
.footer{
  position:fixed;
  bottom:0;
  left:0;
  right:0;
  background:#fff;
  padding:10px;
  border-top:1px solid #ddd;
}
.footer button{
  width:100%;
  padding:14px;
  background:#fb641b;
  border:none;
  color:#fff;
  font-size:18px;
  border-radius:6px;
}
</style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9977276800228616"
     crossorigin="anonymous"></script>
</head>

<body>

<div class="header" id="backHeader">&larr; Order Details</div>

<!-- STEP 1 ADDRESS -->
<div class="section">
  <div class="step"><span>1</span><b>Delivery Address</b></div>

  <input class="input" id="name" placeholder="Full Name">
  <input class="input" id="phone" type="tel" inputmode="tel" placeholder="Mobile Number">
  <select class="input" id="country">
    <option value="">Select Country</option>
  </select>
  <input class="input" id="address" placeholder="House / Area">
  <div class="input-row">
    <input class="input" id="city" placeholder="City">
    <input class="input" id="pincode" placeholder="Pincode">
  </div>
</div>

<!-- STEP 2 ORDER SUMMARY -->
<div class="section">
  <div class="step"><span>2</span><b>Order Summary</b></div>
  <div id="items"></div>
</div>

<!-- PRICE SUMMARY -->
<div class="section summary">
  <div><span>Price</span><span id="price">$0</span></div>
  <div><span>Discount</span><span id="discount">- $0</span></div>
  <div class="total"><span>Total</span><span id="total">$0</span></div>
</div>

<!-- PAYMENT -->
<div class="section">
  <div class="step"><span>3</span><b>Payment</b></div>
  <p>Secure UPI / Card / Netbanking (Next Step)</p>
</div>

<div class="footer">
  <button onclick="placeOrder()">Continue to Payment</button>
</div>

<script>
function ensureUser(){
  if(currentUser) return Promise.resolve(currentUser);
  if(!supa || !supa.auth) return Promise.resolve(null);
  return supa.auth.getSession().then(({ data }) => {
    currentUser = data?.session?.user || null;
    return currentUser;
  });
}
let currentUser = null;
const supa = window.supa || window.novaCreateSupabaseClient();
if(!supa){
  location.href = "login.html";
  throw new Error("supabase_client_unavailable");
}

/* LOAD CART */
let cart = [];
let itemsBox = document.getElementById("items");
let total = 0;
let isPlacingOrder = false;
const countryInput = document.getElementById("country");
const ALL_COUNTRY_NAMES = [
  "Afghanistan",
  "Albania",
  "Algeria",
  "Andorra",
  "Angola",
  "Antigua and Barbuda",
  "Argentina",
  "Armenia",
  "Australia",
  "Austria",
  "Azerbaijan",
  "Bahamas",
  "Bahrain",
  "Bangladesh",
  "Barbados",
  "Belarus",
  "Belgium",
  "Belize",
  "Benin",
  "Bhutan",
  "Bolivia",
  "Bosnia and Herzegovina",
  "Botswana",
  "Brazil",
  "Brunei",
  "Bulgaria",
  "Burkina Faso",
  "Burundi",
  "Cabo Verde",
  "Cambodia",
  "Cameroon",
  "Canada",
  "Central African Republic",
  "Chad",
  "Chile",
  "China",
  "Colombia",
  "Comoros",
  "Congo",
  "Costa Rica",
  "Cote d'Ivoire",
  "Croatia",
  "Cuba",
  "Cyprus",
  "Czechia",
  "Democratic Republic of the Congo",
  "Denmark",
  "Djibouti",
  "Dominica",
  "Dominican Republic",
  "Ecuador",
  "Egypt",
  "El Salvador",
  "Equatorial Guinea",
  "Eritrea",
  "Estonia",
  "Eswatini",
  "Ethiopia",
  "Fiji",
  "Finland",
  "France",
  "Gabon",
  "Gambia",
  "Georgia",
  "Germany",
  "Ghana",
  "Greece",
  "Grenada",
  "Guatemala",
  "Guinea",
  "Guinea-Bissau",
  "Guyana",
  "Haiti",
  "Honduras",
  "Hungary",
  "Iceland",
  "India",
  "Indonesia",
  "Iran",
  "Iraq",
  "Ireland",
  "Israel",
  "Italy",
  "Jamaica",
  "Japan",
  "Jordan",
  "Kazakhstan",
  "Kenya",
  "Kiribati",
  "Kosovo",
  "Kuwait",
  "Kyrgyzstan",
  "Laos",
  "Latvia",
  "Lebanon",
  "Lesotho",
  "Liberia",
  "Libya",
  "Liechtenstein",
  "Lithuania",
  "Luxembourg",
  "Madagascar",
  "Malawi",
  "Malaysia",
  "Maldives",
  "Mali",
  "Malta",
  "Marshall Islands",
  "Mauritania",
  "Mauritius",
  "Mexico",
  "Micronesia",
  "Moldova",
  "Monaco",
  "Mongolia",
  "Montenegro",
  "Morocco",
  "Mozambique",
  "Myanmar",
  "Namibia",
  "Nauru",
  "Nepal",
  "Netherlands",
  "New Zealand",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "North Korea",
  "North Macedonia",
  "Norway",
  "Oman",
  "Pakistan",
  "Palau",
  "Palestine",
  "Panama",
  "Papua New Guinea",
  "Paraguay",
  "Peru",
  "Philippines",
  "Poland",
  "Portugal",
  "Qatar",
  "Romania",
  "Russia",
  "Rwanda",
  "Saint Kitts and Nevis",
  "Saint Lucia",
  "Saint Vincent and the Grenadines",
  "Samoa",
  "San Marino",
  "Sao Tome and Principe",
  "Saudi Arabia",
  "Senegal",
  "Serbia",
  "Seychelles",
  "Sierra Leone",
  "Singapore",
  "Slovakia",
  "Slovenia",
  "Solomon Islands",
  "Somalia",
  "South Africa",
  "South Korea",
  "South Sudan",
  "Spain",
  "Sri Lanka",
  "Sudan",
  "Suriname",
  "Sweden",
  "Switzerland",
  "Syria",
  "Taiwan",
  "Tajikistan",
  "Tanzania",
  "Thailand",
  "Timor-Leste",
  "Togo",
  "Tonga",
  "Trinidad and Tobago",
  "Tunisia",
  "Turkey",
  "Turkmenistan",
  "Tuvalu",
  "Uganda",
  "Ukraine",
  "United Arab Emirates",
  "United Kingdom",
  "United States",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Vatican City",
  "Venezuela",
  "Vietnam",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];

function ensureCountryOptions(defaultCountry){
  if(!countryInput) return;
  const uniqueCountries = Array.from(new Set(
    (ALL_COUNTRY_NAMES || [])
      .map(name => String(name || "").trim())
      .filter(Boolean)
  )).sort((a, b) => a.localeCompare(b));

  countryInput.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Select Country";
  countryInput.appendChild(placeholder);

  uniqueCountries.forEach(country => {
    const option = document.createElement("option");
    option.value = country;
    option.textContent = country;
    countryInput.appendChild(option);
  });

  const preferred = String(defaultCountry || "").trim() || "India";
  const match = Array.from(countryInput.options || []).find(opt => String(opt.value || "").toLowerCase() === preferred.toLowerCase());
  if(match){
    countryInput.value = match.value;
    return;
  }
  const custom = document.createElement("option");
  custom.value = preferred;
  custom.textContent = preferred;
  countryInput.appendChild(custom);
  countryInput.value = preferred;
}

const CITY_COORDS = {
  bangalore:[12.9716,77.5946],
  bengaluru:[12.9716,77.5946],
  mumbai:[19.076,72.8777],
  pune:[18.5204,73.8567],
  nagpur:[21.1458,79.0882],
  nashik:[19.9975,73.7898],
  aurangabad:[19.8762,75.3433],
  kolhapur:[16.705,74.2433],
  delhi:[28.6139,77.209],
  newdelhi:[28.6139,77.209],
  noida:[28.5355,77.391],
  gurgaon:[28.4595,77.0266],
  gurugram:[28.4595,77.0266],
  hyderabad:[17.385,78.4867],
  chennai:[13.0827,80.2707],
  kolkata:[22.5726,88.3639],
  ahmedabad:[23.0225,72.5714],
  surat:[21.1702,72.8311],
  jaipur:[26.9124,75.7873],
  indore:[22.7196,75.8577],
  bhopal:[23.2599,77.4126],
  lucknow:[26.8467,80.9462],
  kanpur:[26.4499,80.3319],
  kochi:[9.9312,76.2673],
  cochin:[9.9312,76.2673],
  trivandrum:[8.5241,76.9366],
  thiruvananthapuram:[8.5241,76.9366],
  visakhapatnam:[17.6868,83.2185],
  vijayawada:[16.5062,80.648],
  patna:[25.5941,85.1376],
  ranchi:[23.3441,85.3096],
  bhubaneswar:[20.2961,85.8245],
  guwahati:[26.1445,91.7362],
  chandigarh:[30.7333,76.7794],
  ludhiana:[30.901,75.8573]
};

function normalizeText(value){
  return String(value || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function sanitizePhone(value){
  let raw = String(value || "").trim();
  raw = raw.replace(/[^\d+]/g, "");
  if(raw.startsWith("00")) raw = "+" + raw.slice(2);
  if(raw.startsWith("+")){
    return "+" + raw.slice(1).replace(/[^\d]/g, "");
  }
  return raw.replace(/[^\d]/g, "");
}

function isValidPhone(value){
  const cleaned = sanitizePhone(value);
  const digits = cleaned.replace(/\D/g, "");
  return digits.length >= 8 && digits.length <= 15;
}

function resolveCityCoords(cityName){
  const normalized = normalizeText(cityName).replace(/\s/g, "");
  if(!normalized) return null;
  if(CITY_COORDS[normalized]) return CITY_COORDS[normalized];
  const keys = Object.keys(CITY_COORDS);
  for(const key of keys){
    if(normalized.includes(key) || key.includes(normalized)){
      return CITY_COORDS[key];
    }
  }
  return null;
}

function haversineKm(lat1, lon1, lat2, lon2){
  const toRad = (deg) => (deg * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  return 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function estimateWindowByKm(distanceKm){
  const km = Number(distanceKm);
  if(!Number.isFinite(km) || km <= 0){
    return { min_days:4, max_days:5 };
  }
  if(km <= 80) return { min_days:1, max_days:2 };
  if(km <= 250) return { min_days:2, max_days:3 };
  if(km <= 600) return { min_days:3, max_days:4 };
  if(km <= 1100) return { min_days:4, max_days:5 };
  if(km <= 1600) return { min_days:5, max_days:6 };
  return { min_days:6, max_days:8 };
}

function makeIsoFromNow(days){
  const n = Math.max(0, Number(days) || 0);
  return new Date(Date.now() + n * 24 * 60 * 60 * 1000).toISOString();
}

function formatDistanceLabel(distanceKm){
  const km = Number(distanceKm);
  if(!Number.isFinite(km) || km <= 0) return "";
  return `${Math.round(km)} km`;
}

function makeDeliveryEstimate(buyerCity, sellerCity){
  const buyerCoords = resolveCityCoords(buyerCity);
  const sellerCoords = resolveCityCoords(sellerCity);
  const distanceKm = (buyerCoords && sellerCoords)
    ? haversineKm(buyerCoords[0], buyerCoords[1], sellerCoords[0], sellerCoords[1])
    : null;
  const windowDays = estimateWindowByKm(distanceKm);
  const minDays = Number(windowDays.min_days || 4);
  const maxDays = Number(windowDays.max_days || 5);
  return {
    buyer_city: String(buyerCity || ""),
    seller_city: String(sellerCity || ""),
    distance_km: Number.isFinite(distanceKm) ? Math.round(distanceKm) : null,
    distance_label: formatDistanceLabel(distanceKm),
    min_days: minDays,
    max_days: maxDays,
    label: `${minDays}-${maxDays} days`,
    eta_from: makeIsoFromNow(minDays),
    eta_to: makeIsoFromNow(maxDays)
  };
}

function isMissingColumnError(error){
  const message = String(error?.message || "").toLowerCase();
  const details = String(error?.details || "").toLowerCase();
  const text = `${message} ${details}`;
  return text.includes("column") && text.includes("does not exist");
}

function firstText(...values){
  for(const value of values){
    const v = String(value || "").trim();
    if(v) return v;
  }
  return "";
}

async function fetchSellerLocation(sellerId){
  const cleanSellerId = String(sellerId || "").trim();
  if(!cleanSellerId){
    return { city:"", state:"", country:"", pincode:"", address:"" };
  }

  const userSelects = [
    "user_id,city,state,country,pincode,address",
    "user_id,city,location,pincode,address",
    "user_id,location,pincode,address"
  ];
  for(const selectCols of userSelects){
    const { data, error } = await supa
      .from("users")
      .select(selectCols)
      .eq("user_id", cleanSellerId)
      .maybeSingle();
    if(error){
      if(isMissingColumnError(error)) continue;
      break;
    }
    if(data){
      const city = firstText(data.city, data.location);
      const state = firstText(data.state);
      const country = firstText(data.country);
      const pincode = firstText(data.pincode);
      const address = firstText(data.address, data.location);
      return { city, state, country, pincode, address };
    }
  }

  const sellerSelects = [
    "user_id,city,state,country,pincode,address",
    "user_id,location,pincode,address"
  ];
  for(const selectCols of sellerSelects){
    const { data, error } = await supa
      .from("sellers")
      .select(selectCols)
      .eq("user_id", cleanSellerId)
      .maybeSingle();
    if(error){
      if(isMissingColumnError(error)) continue;
      break;
    }
    if(data){
      const city = firstText(data.city, data.location);
      const state = firstText(data.state);
      const country = firstText(data.country);
      const pincode = firstText(data.pincode);
      const address = firstText(data.address, data.location);
      return { city, state, country, pincode, address };
    }
  }

  return { city:"", state:"", country:"", pincode:"", address:"" };
}

if(countryInput){
  const storedCountry = String(window.USER_COUNTRY || "").trim();
  ensureCountryOptions(storedCountry || "India");
}

function toUserCurrency(amount, fromCur){
  if(typeof window.convertCurrency === "function"){
    return convertCurrency(Number(amount) || 0, fromCur || "USD", window.USER_CURRENCY || "USD");
  }
  return Number(amount) || 0;
}

function renderCart(){
  cart = JSON.parse(localStorage.getItem("cart")) || [];
  cart = (cart || [])
    .map(p=>({
      id: p.id || null,
      owner_id: p.owner_id || null,
      name: p.name || "",
      images: Array.isArray(p.images) ? p.images : [],
      image: p.image || "",
      price: Number(p.price || 0),
      qty: Number(p.qty || 0),
      currency: p.currency || "USD"
    }))
    .filter(p=>p.id && p.qty > 0);

  if(cart.length === 0){
    alert("Cart is empty");
    location.href = "cart.html";
    return;
  }

  itemsBox.innerHTML = "";
  total = 0;
  cart.forEach(p=>{
    total += toUserCurrency((p.price || 0) * (p.qty || 0), p.currency);
    itemsBox.innerHTML += `
      <div class="cart-item">
        <img src="${p.images?.[0] || p.image}">
        <div>
          <div class="cart-title">${translateProductName(p.name)}</div>
          <div>Qty: ${p.qty}</div>
          <div class="cart-price">${money(p.price, p.currency)}</div>
        </div>
      </div>
    `;
  });

  document.getElementById("price").innerText = money(total || 0, window.USER_CURRENCY || "USD");
  document.getElementById("discount").innerText = "- " + money(0, window.USER_CURRENCY || "USD");
  document.getElementById("total").innerText = money(total || 0, window.USER_CURRENCY || "USD");
}

renderCart();
document.addEventListener("ratesUpdated", renderCart);

function buildAutomationApiBases(){
  const out = [""];
  const push = (raw) => {
    const val = String(raw || "").trim().replace(/\/+$/g, "");
    if(!val) return;
    if(!/^https?:\/\//i.test(val)) return;
    if(!out.includes(val)) out.push(val);
  };
  push(window.CONTEST_API_BASE || window.API_BASE || "");
  try{
    push(localStorage.getItem("contest_api_base"));
    push(localStorage.getItem("api_base"));
  }catch(_){ }
  if(/^https?:\/\//i.test(location.origin || "")) push(location.origin);
  push("https://novagapp-mart.onrender.com");
  return out;
}

async function trackAutomationStep(step, userId, meta){
  const uid = String(userId || "").trim();
  if(!uid) return;
  const payload = {
    user_id: uid,
    step: String(step || "").trim().toLowerCase(),
    meta: meta && typeof meta === "object" ? meta : {}
  };
  const bases = buildAutomationApiBases();
  for(const base of bases){
    try{
      const res = await fetch(`${base}/api/automation/track`, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      if(res.ok) break;
    }catch(_){ }
  }
}

/* PLACE ORDER (SUPABASE DB) */
async function placeOrder(){
  if(isPlacingOrder) return;
  const user = await ensureUser();
  if(!user){
    location.href = "login.html";
    return;
  }
  if(!Array.isArray(cart) || cart.length === 0){
    return;
  }
  let name = document.getElementById("name").value.trim();
  let phone = sanitizePhone(document.getElementById("phone").value.trim());
  let country = document.getElementById("country").value.trim();
  let address = document.getElementById("address").value.trim();
  let city = document.getElementById("city").value.trim();
  let pincode = document.getElementById("pincode").value.trim();

  if(!name || !phone || !country || !address || !city || !pincode){
    alert("Please fill all address details");
    return;
  }
  if(!isValidPhone(phone)){
    alert("Please enter a valid phone number.");
    return;
  }

  isPlacingOrder = true;
  const cartWithOwners = await hydrateCartOwnerIds(cart);
  const orderItems = (cartWithOwners || []).map((item)=>({
    id: item.id,
    name: item.name,
    price: Number(item.price || 0),
    currency: item.currency || "USD",
    qty: Number(item.qty || 0),
    owner_id: item.owner_id || null,
    images: Array.isArray(item.images) ? item.images : []
  }));

  const sellerIds = [...new Set(orderItems.map(i=>i.owner_id).filter(Boolean))];
  if(sellerIds.length !== 1){
    isPlacingOrder = false;
    alert("Please place separate orders for each seller.");
    return;
  }
  const sellerId = sellerIds[0];
  const sellerLocation = await fetchSellerLocation(sellerId);
  const deliveryEstimate = makeDeliveryEstimate(city, sellerLocation.city);
  const buyerAddressPayload = {
    name,
    phone,
    email: user.email || "",
    country,
    address,
    city,
    pincode,
    seller_city: sellerLocation.city || "",
    seller_state: sellerLocation.state || "",
    delivery_estimate: deliveryEstimate
  };

  const order = {
    user_id: user.id,
    seller_id: sellerId,
    email: user.email || "",
    buyer_name: name,
    buyer_address: buyerAddressPayload,
    address: buyerAddressPayload,
    items: orderItems,
    amount: Number(total || 0),
    total: Number(total || 0),
    currency: localStorage.getItem("currency") || "USD",
    status: "placed",
    payment_method: "Pending Payment",
    payment_status: "pending"
  };

  const { data, error } = await supa
    .from("orders")
    .insert(order)
    .select("*")
    .single();

  if(error || !data?.id){
    isPlacingOrder = false;
    alert("Order failed. Please try again.");
    if(error) console.error(error);
    return;
  }

  const stockResult = await reserveStockForOrderItems(orderItems);
  if(!stockResult.ok){
    await supa.from("orders").delete().eq("id", data.id);
    isPlacingOrder = false;
    alert(stockResult.message || "Not enough stock for one or more products.");
    return;
  }

  localStorage.setItem("lastOrderId", data.id);
  localStorage.setItem("lastOrder", JSON.stringify(data));

  await createSellerNotifications({
    orderId: data.id,
    buyer: {
      name,
      phone,
      email: user.email || "",
      country,
      address,
      city,
      pincode
    },
    items: orderItems,
    total,
    currency: order.currency,
    payment_method: order.payment_method,
    sellerLocation,
    deliveryEstimate
  });

  trackAutomationStep("checkout", user.id, {
    order_id: data.id,
    seller_id: sellerId,
    item_count: orderItems.length,
    total_amount: Number(total || 0),
    currency: order.currency
  }).catch(()=>{});

  /* OPTIONAL: clear cart after order */
  localStorage.removeItem("cart");

  location.href = "payment.html";
}

async function reserveStockForOrderItems(orderItems){
  const qtyByProduct = {};
  (orderItems || []).forEach(item => {
    const productId = String(item?.id || "").trim();
    const qty = Math.max(0, Number(item?.qty || 0));
    if(!productId || qty <= 0) return;
    qtyByProduct[productId] = (qtyByProduct[productId] || 0) + qty;
  });

  const productIds = Object.keys(qtyByProduct);
  if(productIds.length === 0){
    return { ok:true };
  }

  const { data, error } = await supa
    .from("products")
    .select("id,owner_id,quantity")
    .in("id", productIds);

  if(error){
    console.error("stock_fetch_failed", error);
    return { ok:false, message:"Unable to verify stock right now." };
  }

  const byId = {};
  (data || []).forEach(row => {
    byId[row.id] = row;
  });

  for(const productId of productIds){
    const row = byId[productId];
    const need = qtyByProduct[productId] || 0;
    const have = Math.max(0, Number(row?.quantity || 0));
    if(!row || have < need){
      return { ok:false, message:"Stock finished for one of the selected products." };
    }
  }

  const applied = [];
  try{
    for(const productId of productIds){
      const row = byId[productId];
      const need = qtyByProduct[productId] || 0;
      const prevQty = Math.max(0, Number(row?.quantity || 0));
      const nextQty = Math.max(0, prevQty - need);

      const { error: updateErr } = await supa
        .from("products")
        .update({ quantity: nextQty })
        .eq("id", productId)
        .eq("owner_id", row.owner_id);

      if(updateErr){
        throw updateErr;
      }

      applied.push({ id: productId, prevQty });
    }

    return { ok:true };
  }catch(err){
    console.error("stock_update_failed", err);
    for(const row of applied){
      try{
        await supa
          .from("products")
          .update({ quantity: row.prevQty })
          .eq("id", row.id);
      }catch(_){ }
    }
    return { ok:false, message:"Stock update failed. Please retry." };
  }
}

async function hydrateCartOwnerIds(items){
  const base = Array.isArray(items) ? [...items] : [];
  const productIds = [...new Set(base.map(i=>i.id).filter(Boolean))];
  if(productIds.length === 0) return base;

  const { data, error } = await supa
    .from("products")
    .select("id,owner_id")
    .in("id", productIds);

  if(error){
    console.error(error);
    return base;
  }

  const ownerMap = {};
  (data || []).forEach(p=>{
    ownerMap[p.id] = p.owner_id || null;
  });

  return base.map(i=>({
    ...i,
    owner_id: i.owner_id || ownerMap[i.id] || null
  }));
}

function normalizePaymentMethodLabel(method){
  const m = String(method || "").trim().toLowerCase();
  if(!m) return "Pending Payment";
  if(m.includes("cash") || m.includes("cod")) return "Cash on Delivery";
  if(m.includes("upi")) return "UPI / Wallets";
  if(m.includes("netbanking") || m.includes("net banking")) return "Net Banking";
  if(m.includes("card")) return "Credit / Debit Card";
  if(m.includes("online") || m.includes("razorpay")) return "Online Payment";
  return method;
}

async function createSellerNotifications(payload){
  const { orderId, buyer, items, total, currency, payment_method, sellerLocation, deliveryEstimate } = payload;
  const paymentText = normalizePaymentMethodLabel(payment_method);
  const buyerAddress = `${buyer?.address || ""}, ${buyer?.city || ""} ${buyer?.pincode || ""}, ${buyer?.country || ""}`.trim();
  const sellerAddress = `${sellerLocation?.city || ""} ${sellerLocation?.state || ""}, ${sellerLocation?.country || ""}`.trim();
  const deliveryText = deliveryEstimate?.label ? `${deliveryEstimate.label}` : "4-5 days";
  const distanceText = deliveryEstimate?.distance_label ? ` (${deliveryEstimate.distance_label})` : "";
  const groups = {};
  (items || []).forEach((i)=>{
    const sellerId = i.owner_id || null;
    if(!sellerId) return;
    if(!groups[sellerId]) groups[sellerId] = [];
    groups[sellerId].push(i);
  });

  const sellerIds = Object.keys(groups);
  if(sellerIds.length === 0) return;

  for(const sellerId of sellerIds){
    const sellerItems = groups[sellerId] || [];
    const primary = sellerItems[0] || {};
    const qty = sellerItems.reduce((sum, item)=>sum + Number(item?.qty || 0), 0);
    const sellerTotal = sellerItems.reduce((sum, item)=>sum + (Number(item?.price || 0) * Number(item?.qty || 0)), 0);
    const productSummary = sellerItems
      .map(item=>`${item.name || "Product"} x${Number(item.qty || 0)}`)
      .join(", ");
    const message =
      `Buyer: ${buyer?.name || ""} | Phone: ${buyer?.phone || ""} | Email: ${buyer?.email || ""} | Country: ${buyer?.country || ""} | Address: ${buyerAddress} | Seller Location: ${sellerAddress || "-"} | Product: ${productSummary} | Qty: ${qty} | Payment: ${paymentText} | ETA: ${deliveryText}${distanceText}`;

    const row = {
      receiver_user_id: sellerId,
      seller_id: sellerId,
      type: "new_order",
      title: "New Order Received",
      message,
      order_id: orderId,
      product_id: primary.id || null,
      product_name: primary.name || "",
      qty,
      buyer_name: buyer?.name || "",
      buyer_address: buyerAddress,
      buyer_phone: buyer?.phone || "",
      payment_method: paymentText,
      total: Number(sellerTotal || 0),
      currency: currency || "USD",
      is_read: false,
      is_deleted: false
    };

    const { error } = await supa.from("notifications").insert([row]);
    if(error) console.error("Failed to create seller notification:", error);
  }
}
</script>

</body>
</html>
