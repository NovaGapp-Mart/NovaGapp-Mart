<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Sign Up - NOVAGAPP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="icon" href="favicon.ico">
  <link rel="stylesheet" href="style.css">

  <!-- SUPABASE SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="public-config.js"></script>

  <!-- GLOBAL INIT -->
  <script src="global.js"></script>

  <style>
    .password-box{ position:relative }
    .toggle-password{
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
      cursor:pointer;
    }
  </style>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9977276800228616"
     crossorigin="anonymous"></script>
</head>

<body class="login-body">

<div class="login-card">
  <img src="Images/logo.png" class="login-logo">
  <h2 class="login-title">Create NOVAGAPP Account</h2>

  <!-- EMAIL -->
  <div class="input-box">
    <input id="email" type="email" placeholder="Email">
  </div>

  <!-- PASSWORD -->
  <div class="input-box password-box">
    <input id="password" type="password" placeholder="Password">
    <span class="toggle-password" onclick="togglePassword()" role="button" aria-label="Toggle password">Show</span>
  </div>

  <button class="login-btn" onclick="signup()">Sign Up</button>

  <div class="or">OR</div>

  <!-- GOOGLE SIGNUP -->
  <button class="google-btn" onclick="googleSignup()">
    <img src="https://img.icons8.com/color/48/google-logo.png">
    Sign up with Google
  </button>

  <div class="signup">
    Already have an account?
    <span onclick="location.href='login.html'">Login</span>
  </div>
</div>

<script>
const APP_PUBLIC_ORIGIN = "https://novagapp-mart.onrender.com";

function normalizeConfig(raw){
  return {
    supabaseUrl: String(raw?.supabaseUrl || "").trim(),
    supabaseAnonKey: String(raw?.supabaseAnonKey || "").trim()
  };
}

async function ensureSupaClient(){
  if(window.supa){
    return window.supa;
  }

  let cfg = normalizeConfig(window.NOVA_PUBLIC_CONFIG || window.__NOVA_PUBLIC_CONFIG__ || {});
  if((!cfg.supabaseUrl || !cfg.supabaseAnonKey) && typeof window.getNovaPublicConfig === "function"){
    try{
      cfg = normalizeConfig(await window.getNovaPublicConfig(true));
    }catch(_){ }
  }

  if(!cfg.supabaseUrl || !cfg.supabaseAnonKey){
    throw new Error("Supabase public config missing");
  }

  window.supa = window.supabase.createClient(
    cfg.supabaseUrl,
    cfg.supabaseAnonKey,
    { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:true } }
  );
  return window.supa;
}

window.ensureSupaClient = window.ensureSupaClient || ensureSupaClient;
window.ensureSupaClient().catch(err => {
  console.warn("Supabase init failed:", err?.message || err);
});

function buildContestApiCandidates(){
  const out = [];
  const DEFAULT_REMOTE_API_BASE = "https://novagapp-mart.onrender.com";
  const push = (raw) => {
    const val = String(raw || "").trim().replace(/\/+$/g, "");
    if(!val) return;
    if(!/^https?:\/\//i.test(val)) return;
    const isLoopback = /^http:\/\//i.test(val);
    const allowLoopback = location.protocol === "file:";
    if(isLoopback && !allowLoopback) return;
    if(out.includes(val)) return;
    out.push(val);
  };

  const isLocal = location.protocol === "file:";
  const qp = new URLSearchParams(location.search);
  push(DEFAULT_REMOTE_API_BASE);
  push(qp.get("api_base"));
  try{
    push(localStorage.getItem("contest_api_base"));
    push(localStorage.getItem("api_base"));
  }catch(_){ }
  push(window.CONTEST_API_BASE || window.API_BASE || "");
  if(isLocal){
    push("https://novagapp-mart.onrender.com");
    push("https://novagapp-mart.onrender.com");
  }
  if(!out.length && /^https?:\/\//i.test(location.origin)){
    out.push(location.origin.replace(/\/+$/g, ""));
  }
  return out;
}

async function registerContestAccount(user){
  if(!user?.id) return false;
  const payload = {
    user_id: String(user.id || "").trim(),
    user_name: String((user.user_metadata?.full_name || user.user_metadata?.name || user.email || "").split("@")[0] || "").trim(),
    email: String(user.email || "").trim()
  };
  const candidates = buildContestApiCandidates();
  for(const base of candidates){
    try{
      const res = await fetch(base + "/api/contest/account/register", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      if(res.ok) return true;
    }catch(_){ }
  }
  return false;
}

function toTitleCaseWords(text){
  return String(text || "")
    .split(/\s+/)
    .map(part => {
      const token = String(part || "").trim();
      if(!token) return "";
      return token.slice(0, 1).toUpperCase() + token.slice(1).toLowerCase();
    })
    .filter(Boolean)
    .join(" ")
    .slice(0, 60);
}

function splitCompactToken(value){
  const token = String(value || "").toLowerCase().replace(/[^a-z]+/g, "");
  if(token.length < 9){
    return token ? [token] : [];
  }
  const mid = Math.floor(token.length / 2);
  const minSide = 3;
  let bestIdx = -1;
  let bestWeight = -Infinity;
  for(let i = minSide; i <= token.length - minSide; i += 1){
    const prev = token[i - 1];
    const next = token[i];
    const prevVowel = /[aeiou]/.test(prev);
    const nextVowel = /[aeiou]/.test(next);
    const dist = Math.abs(i - mid);
    let weight = 0;
    if(prevVowel && !nextVowel) weight += 4;
    if(!prevVowel && nextVowel) weight += 3;
    if(dist <= 1) weight += 3;
    else if(dist <= 2) weight += 2;
    else if(dist <= 4) weight += 1;
    if(i >= 4 && token.length - i >= 4) weight += 1;
    if(weight > bestWeight){
      bestWeight = weight;
      bestIdx = i;
    }
  }
  if(bestIdx <= 0){
    return [token];
  }
  const left = token.slice(0, bestIdx).trim();
  const right = token.slice(bestIdx).trim();
  if(!left || !right){
    return [token];
  }
  return [left, right];
}

function parseEmailLocalWords(local){
  const cleaned = String(local || "")
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, " ")
    .replace(/[._-]+/g, " ")
    .replace(/\d+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  if(!cleaned){
    return "";
  }
  const out = [];
  cleaned.split(/\s+/).forEach(piece => {
    splitCompactToken(piece).forEach(token => {
      const next = String(token || "").trim();
      if(next) out.push(next);
    });
  });
  return out.join(" ").trim().slice(0, 80);
}

function deriveIdentity(user){
  const email = String(user?.email || "").trim().toLowerCase();
  const local = String((email.split("@")[0] || "")).trim();
  const words = parseEmailLocalWords(local);
  const displayName = toTitleCaseWords(
    String(user?.user_metadata?.full_name || user?.user_metadata?.name || words || local || "Member")
  ) || "Member";
  const username = String(local || displayName || "member")
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "")
    .slice(0, 24) || "member";
  const emailLocal = local.slice(0, 120);
  const searchTokens = Array.from(new Set(
    `${displayName} ${username} ${emailLocal} ${email}`
      .toLowerCase()
      .replace(/[^a-z0-9@._ -]/g, " ")
      .split(/[\s@._-]+/)
      .map(s => s.trim())
      .filter(Boolean)
  )).slice(0, 40);
  return { email, emailLocal, displayName, username, searchTokens };
}

function extractMissingColumnName(error){
  const text = `${error?.message || ""} ${error?.details || ""}`;
  const pgMatch = text.match(/column\s+\"?([a-zA-Z0-9_.]+)\"?\s+does not exist/i);
  if(pgMatch && pgMatch[1]){
    return String(pgMatch[1]).split(".").pop().toLowerCase();
  }
  const quoted = text.match(/'([a-zA-Z0-9_]+)'/);
  if(quoted && quoted[1]){
    return String(quoted[1]).toLowerCase();
  }
  return "";
}

function isAuthOrRlsWriteError(error){
  const code = String(error?.code || "").trim();
  const status = Number(error?.status || 0);
  const text = `${error?.message || ""} ${error?.details || ""}`.toLowerCase();
  return (
    code === "42501" ||
    status === 401 ||
    status === 403 ||
    text.includes("row-level security")
  );
}

async function upsertProfileRow(supa, user, identity){
  if(!supa || !user?.id) return false;
  let hasSessionForUser = false;
  try{
    const { data } = await supa.auth.getSession();
    hasSessionForUser = Boolean(
      data?.session?.access_token &&
      data?.session?.user?.id &&
      data.session.user.id === user.id
    );
  }catch(_){ }
  if(!hasSessionForUser){
    return false;
  }

  let row = {
    user_id: user.id,
    email: identity.email || user.email || "",
    email_local: identity.emailLocal || "",
    username: identity.username || "member",
    full_name: identity.displayName || "Member",
    display_name: identity.displayName || "Member",
    search_tokens: identity.searchTokens || [],
    role: "user"
  };
  const required = new Set(["user_id"]);
  for(let attempt = 0; attempt < 8; attempt += 1){
    const { error } = await supa
      .from("users")
      .upsert(row, { onConflict: "user_id" });
    if(!error){
      return true;
    }
    if(isAuthOrRlsWriteError(error)){
      return false;
    }
    const missing = extractMissingColumnName(error);
    if(missing && Object.prototype.hasOwnProperty.call(row, missing) && !required.has(missing)){
      delete row[missing];
      continue;
    }
    throw error;
  }
  return false;
}

async function syncAccountIdentity(user, identity){
  if(!user?.id) return false;
  const payload = {
    user_id: user.id,
    email: identity?.email || user.email || "",
    username: identity?.username || "",
    full_name: identity?.displayName || "",
    display_name: identity?.displayName || ""
  };
  const candidates = buildContestApiCandidates();
  for(const base of candidates){
    try{
      const res = await fetch(base + "/api/account/sync", {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      if(res.ok) return true;
    }catch(_){ }
  }
  return false;
}

/* TOGGLE PASSWORD */
function togglePassword(){
  const p = document.getElementById("password");
  p.type = p.type === "password" ? "text" : "password";
}

/* SIGNUP (PASSWORD ONLY) */
async function signup(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(err){
    alert("Supabase config missing. Start server on port 3000 or check public-config.js");
    return;
  }

  const email = document.getElementById("email").value.trim();
  const password = document.getElementById("password").value;

  if(!email || !password){
    alert("Email & password required");
    return;
  }

  const local = String((email.split("@")[0] || "")).trim();
  const suggestedName = toTitleCaseWords(parseEmailLocalWords(local) || local) || "Member";

  const { data, error } = await supa.auth.signUp({
    email,
    password,
    options: {
      data: {
        full_name: suggestedName,
        name: suggestedName
      }
    }
  });

  if(error){
    alert(error.message);
    return;
  }

  const user = data?.user || null;
  if(!user?.id){
    alert("Signup done. Verify email from inbox, then login.");
    location.href = "login.html";
    return;
  }
  const identity = deriveIdentity(user || { email });
  let profileSynced = false;

  try{
    profileSynced = await syncAccountIdentity(user, identity);
  }catch(_){ }

  if(!profileSynced){
    try{
      await upsertProfileRow(supa, user, identity);
    }catch(profileErr){
      console.warn("profile sync warning", profileErr);
    }
  }

  try{
    await registerContestAccount(user);
  }catch(_){ }

  if(data?.session){
    alert("Account created successfully. Please login.");
  }else{
    alert("Account created. Verify email from inbox, then login.");
  }
  location.href = "login.html";
}

/* GOOGLE SIGNUP */
async function googleSignup(){
  let supa;
  try{
    supa = await window.ensureSupaClient();
  }catch(err){
    alert("Supabase config missing. Start server on port 3000 or check public-config.js");
    return;
  }

  await supa.auth.signInWithOAuth({
    provider:"google",
    options:{
      redirectTo: APP_PUBLIC_ORIGIN + "/onboarding.html"
    }
  });
}
</script>

</body>
</html>
