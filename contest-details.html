<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NOVAGAPP Contest Battle</title>
<script>
(() => {
  const src = new URLSearchParams(location.search);
  const host = String(location.hostname || "").toLowerCase();
  const isLocalHost = host === "127.0.0.1" || host === "localhost";
  const onLiveServer = String(location.port || "") === "5500";
  const explicitBase = String(src.get("api_base") || "").trim().replace(/\/+$/g, "");
  if(!explicitBase){
    if(isLocalHost && onLiveServer){
      window.CONTEST_API_BASE = "http://127.0.0.1:3000";
    }
    return;
  }
  let loopback = false;
  try{
    const host = String(new URL(explicitBase).hostname || "").toLowerCase();
    loopback = host === "127.0.0.1" || host === "localhost";
  }catch(_){
    return;
  }
  const rawFlag = String(
    src.get("allow_local_api") ||
    src.get("force_local_api") ||
    src.get("local_api") ||
    ""
  ).trim().toLowerCase();
  const allowLocal = rawFlag === "1" || rawFlag === "true" || rawFlag === "yes";
  const canUseRelative = String(location.port || "") === "3000";
  if(loopback && !(allowLocal || canUseRelative || isLocalHost)){
    return;
  }
  window.CONTEST_API_BASE = explicitBase;
})();
</script>
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="public-config.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;700;800&family=Space+Grotesk:wght@600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#f7f1e9;
  --bg-spot:#f6d4ad;
  --card:#ffffff;
  --line:#ffd3a8;
  --ink:#2f1d0f;
  --muted:#7f502b;
  --orange:#ff6a00;
  --orange-dark:#cc4f00;
  --sand:#fff6eb;
}
*{box-sizing:border-box}
html,body{margin:0;padding:0}
body{
  font-family:"Manrope",system-ui,sans-serif;
  color:var(--ink);
  background:
    radial-gradient(circle at 8% 10%, var(--bg-spot) 0%, transparent 36%),
    radial-gradient(circle at 92% 0%, #f07a0b 0%, transparent 28%),
    linear-gradient(180deg, #f1a307 0%, var(--bg) 58%, #f08902 100%);
}
.page{
  width:min(1020px,94vw);
  margin:0 auto;
  padding:18px 0 34px;
  display:grid;
  gap:12px;
}
.card{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:18px;
  padding:16px;
  box-shadow:0 14px 28px rgba(102,51,20,.08);
}
.hero{
  border:2px solid #ffba82;
  background:linear-gradient(160deg,#fffaf3 0%,#fff2e3 72%);
}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
.back-link,.mini-link{
  display:inline-block;
  text-decoration:none;
  color:var(--ink);
  font-weight:800;
  background:#fff;
  border:1px solid var(--line);
  border-radius:999px;
  padding:9px 14px;
}
.chip{
  font-size:12px;
  font-weight:800;
  letter-spacing:.06em;
  text-transform:uppercase;
  color:#763200;
  background:#ffd9b7;
  border:1px solid #ffbb7d;
  border-radius:999px;
  padding:8px 12px;
}
h1,h2,h3,p{margin:0}
h1{
  font-family:"Space Grotesk",sans-serif;
  font-size:clamp(26px,3.9vw,40px);
  line-height:1.08;
}
h2{
  font-family:"Space Grotesk",sans-serif;
  font-size:clamp(18px,2.6vw,24px);
}
.muted{margin-top:8px;color:var(--muted);font-size:14px;line-height:1.48}
.metrics{
  margin-top:14px;
  display:grid;
  grid-template-columns:repeat(4,minmax(150px,1fr));
  gap:10px;
}
.metric{
  border:1px solid var(--line);
  border-radius:13px;
  padding:11px;
  background:#fff;
}
.metric small{display:block;color:var(--muted);font-size:11px;font-weight:700;letter-spacing:.03em}
.metric strong{display:block;margin-top:5px;font-size:15px}
.prize-card{
  background:linear-gradient(180deg,var(--sand) 0%,#fff 100%);
}
.prize-list{margin:12px 0 0;padding-left:19px;display:grid;gap:7px;color:#5a3a1f;line-height:1.45}
.battle-card{
  background:linear-gradient(180deg,#fff 0%,#fff9f2 100%);
}
.battle{display:grid;grid-template-columns:1fr auto 1fr;gap:12px;align-items:center;margin-top:12px}
.fighter{
  border:1px solid var(--line);
  border-radius:14px;
  background:#fff;
  padding:12px;
  display:grid;
  justify-items:center;
  gap:9px;
}
.fighter img{
  width:min(230px,100%);
  aspect-ratio:3/4;
  border-radius:12px;
  border:3px solid #ffc692;
  background:#fff;
  object-fit:cover;
}
.fighter h3{font-size:17px;line-height:1.22;text-align:center}
.vs{
  width:68px;
  height:68px;
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  background:radial-gradient(circle at 30% 20%, #ffa55d 0%, #ff6a00 70%);
  color:#fff;
  font-weight:900;
  font-size:20px;
  box-shadow:0 14px 26px rgba(255,106,0,.25);
}
.bars{margin-top:12px;display:grid;gap:8px}
.bar small{display:flex;justify-content:space-between;font-size:12px;color:#6f3f18;font-weight:700}
.track{margin-top:4px;height:9px;background:#ffe4c8;border-radius:999px;overflow:hidden}
.track span{display:block;height:100%;background:linear-gradient(90deg,#ffbb70,#ff6a00)}
.vote-card{
  background:linear-gradient(180deg,#fff 0%,#fff7ee 100%);
}
.side-row,.pack-row{
  margin-top:12px;
  display:flex;
  flex-wrap:wrap;
  gap:9px;
}
.side-btn,.pack-btn{
  border-radius:12px;
  border:1px solid var(--line);
  background:#fff;
  color:#5d3412;
  font-size:14px;
  font-weight:800;
  cursor:pointer;
}
.side-btn{
  padding:10px 14px;
}
.pack-btn{
  flex:1 1 180px;
  min-height:74px;
  text-align:left;
  padding:10px 12px;
  display:grid;
  align-content:center;
  gap:4px;
  transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
}
.pack-label{font-size:12px;color:#7f4d25}
.pack-price{font-size:19px;font-family:"Space Grotesk",sans-serif}
.pack-tag{
  justify-self:start;
  font-size:10px;
  font-weight:900;
  letter-spacing:.06em;
  text-transform:uppercase;
  background:#ffe2c5;
  color:#8d3f00;
  border-radius:999px;
  padding:3px 7px;
}
.pack-btn:hover{
  transform:translateY(-2px);
  box-shadow:0 12px 18px rgba(255,106,0,.14);
}
.side-btn.active,.pack-btn.active{
  background:linear-gradient(150deg,#ff6a00 0%,#ff8b2a 100%);
  color:#fff;
  border-color:#ff6a00;
}
.side-btn.active .pack-label,.pack-btn.active .pack-label{color:#ffe5d0}
.side-btn.active .pack-tag,.pack-btn.active .pack-tag{
  background:rgba(255,255,255,.2);
  color:#fff0e3;
}
button{
  border:none;
  background:linear-gradient(150deg,#ff6a00 0%,#ff8d2e 100%);
  color:#fff;
  font-weight:800;
  border-radius:12px;
  padding:13px 16px;
  cursor:pointer;
  font-size:15px;
  margin-top:12px;
  width:100%;
}
button:disabled{opacity:.55;cursor:not-allowed}
.selection-summary{
  margin-top:12px;
  border:1px solid #ffd2a8;
  background:#fff8f1;
  border-radius:12px;
  padding:11px 12px;
  font-size:13px;
  font-weight:700;
  color:#6f3f18;
  line-height:1.45;
}
.state-pills{
  margin-top:10px;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}
.pill{
  border-radius:999px;
  font-size:11px;
  font-weight:800;
  letter-spacing:.04em;
  text-transform:uppercase;
  padding:6px 10px;
  border:1px solid #ffd2a8;
  background:#fff;
  color:#6f3f18;
}
.pill.good{
  border-color:#8fd0ab;
  background:#edfff4;
  color:#146238;
}
.pill.bad{
  border-color:#efac9f;
  background:#fff2ef;
  color:#8f2914;
}
.insight-card{
  background:linear-gradient(180deg,#fff 0%,#fff8ee 100%);
}
.insight-grid{
  margin-top:12px;
  display:grid;
  grid-template-columns:repeat(2,minmax(220px,1fr));
  gap:10px;
}
.mini-panel{
  border:1px solid #ffd7b1;
  border-radius:12px;
  background:#fff;
  padding:11px;
}
.mini-panel h3{
  font-size:14px;
  margin:0;
}
.mini-metrics{
  margin-top:8px;
  display:grid;
  gap:6px;
  font-size:13px;
  color:#6f3f18;
}
.mini-metrics strong{
  color:#3f220f;
  font-size:15px;
  font-family:"Space Grotesk",sans-serif;
}
.leader-list{
  margin:8px 0 0;
  padding-left:20px;
  display:grid;
  gap:6px;
  color:#5f3518;
  font-size:13px;
}
.leader-list li{
  display:flex;
  justify-content:space-between;
  gap:8px;
}
.leader-name{
  font-weight:700;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.leader-score{
  font-weight:800;
  color:#8c3700;
}
.notice{margin-top:10px;font-size:13px;color:var(--muted);line-height:1.45}
.notice.warn{color:#b2381f}
.toast{position:fixed;right:16px;bottom:16px;padding:10px 12px;border-radius:10px;font-size:13px;opacity:0;pointer-events:none;transition:opacity .2s ease;color:#fff}
.toast.show{opacity:1}
.toast.err{background:#b23622}
.toast.ok{background:#1f8b4b}
@media (max-width:900px){
  .metrics{grid-template-columns:repeat(2,minmax(140px,1fr))}
  .battle{grid-template-columns:1fr}
  .vs{margin:0 auto}
  .insight-grid{grid-template-columns:1fr}
}
@media (max-width:540px){
  .metrics{grid-template-columns:1fr}
}
</style>
</head>
<body>
<main class="page">
  <section class="card hero">
    <div class="row">
      <a class="back-link" id="backLink" href="contest.html">Back to Contest List</a>
      <span class="chip" id="chipText">NOVAGAPP VS BATTLE</span>
    </div>
    <h1 id="battleTitle">Contest Battle</h1>
    <p class="muted" id="battleSubtitle">Loading...</p>
    <div class="metrics">
      <article class="metric"><small id="metricDownloadLabel">Download Gate</small><strong id="downloadsValue">0 / 5,000,000</strong></article>
      <article class="metric"><small id="metricResultLabel">Result Status</small><strong id="resultStatus">Locked</strong></article>
      <article class="metric"><small id="metricGatewayLabel">Gateway</small><strong id="gatewayStatus">Checking...</strong></article>
      <article class="metric"><small id="metricSupabaseLabel">Supabase Sync</small><strong id="supabaseStatus">Checking...</strong></article>
    </div>
  </section>

  <section class="card prize-card">
    <div class="row">
      <h2 id="prizeTitle">Contest Prizes and Rules</h2>
      <a class="mini-link" id="shareLinkBtn" href="contest.html">Share Dashboard</a>
    </div>
    <ul class="prize-list" id="prizeList"></ul>
    <p class="notice" id="ruleLine"></p>
  </section>

  <section class="card battle-card">
    <h2 id="battleSectionTitle">Left Side vs Right Side</h2>
    <div class="battle">
      <article class="fighter">
        <img id="leftImage" alt="Left">
        <h3 id="leftName">Left</h3>
      </article>
      <div class="vs">VS</div>
      <article class="fighter">
        <img id="rightImage" alt="Right">
        <h3 id="rightName">Right</h3>
      </article>
    </div>
    <div class="bars" id="bars"></div>
  </section>

  <section class="card vote-card">
    <h2 id="voteTitle">Voting and Pricing</h2>
    <p class="muted" id="priceInfo">1 Vote = $5, 7 Votes = $25, 20 Votes = $50</p>
    <div class="side-row" id="sideRow"></div>
    <div class="pack-row" id="packRow"></div>
    <div class="selection-summary" id="selectionSummary">Select side and pack to continue checkout.</div>
    <div class="state-pills">
      <span class="pill" id="apiPill">API: Checking</span>
      <span class="pill" id="gatewayPill">Gateway: Checking</span>
    </div>
    <button id="payBtn" type="button">Pay and Vote</button>
    <p class="notice" id="payNotice">Select side and pack to open Razorpay payment.</p>
  </section>

  <section class="card insight-card">
    <h2 id="insightTitle">Live Contest Insights</h2>
    <div class="insight-grid">
      <article class="mini-panel">
        <h3 id="myStatsTitle">My Participation</h3>
        <div class="mini-metrics">
          <div><span id="myPaidVotesLabel">Paid votes</span>: <strong id="myPaidVotesValue">0</strong></div>
          <div><span id="myWeightedLabel">Weighted entries</span>: <strong id="myWeightedValue">0</strong></div>
          <div><span id="mySharesLabel">Share actions</span>: <strong id="mySharesValue">0</strong></div>
        </div>
      </article>
      <article class="mini-panel">
        <h3 id="leaderboardTitle">Top Supporters</h3>
        <ol class="leader-list" id="leaderboardList"></ol>
      </article>
    </div>
  </section>
</main>

<div class="toast" id="toast"></div>

<script>
const SUPABASE_URL = window.NOVA_PUBLIC_CONFIG?.supabaseUrl || "";
const SUPABASE_ANON_KEY = window.NOVA_PUBLIC_CONFIG?.supabaseAnonKey || "";
const RAZORPAY_SDK_URL = "https://checkout.razorpay.com/v1/checkout.js";
const PENDING_VERIFY_STORAGE_KEY = "contest_pending_verify_v1";
const supa = window.supa || createSupabaseClientSafe();
if(supa && !window.supa) window.supa = supa;

function createSupabaseClientSafe(){
  if(!window.supabase?.createClient) return null;
  const url = String(SUPABASE_URL || "").trim();
  const anonKey = String(SUPABASE_ANON_KEY || "").trim();
  if(!url || !anonKey) return null;
  try{
    return window.supabase.createClient(url, anonKey);
  }catch(err){
    console.warn("contest_details_supabase_init_failed", err?.message || err);
    return null;
  }
}

const CONTEST_SIDE_POSTERS = {
  contest_1: { left: "Images/rolls-royce.png", right: "Images/bmw.jpg" },
  contest_2: { left: "Images/niv-cat.jpg", right: "Images/prashik-cat.jpg" },
  contest_3: { left: "Images/many.jpg", right: "Images/prashik-logo-shirt.jpg" },
  contest_4: { left: "Images/bmw.jpg", right: "Images/rolls-royce.png" },
  contest_5: { left: "Images/prashik-cat.jpg", right: "Images/niv-cat.jpg" },
  contest_6: { left: "Images/many.jpg", right: "Images/bmw.jpg" }
};

const state = {
  apiBase:"",
  apiError:"",
  contestId:"",
  data:null,
  userId:"",
  userName:"",
  userEmail:"",
  selectedSide:"",
  selectedPack:"",
  paymentBusy:false,
  supabaseSessionReady:false,
  pendingVerifications:[],
  apiRetryTimer:0,
  apiRetryBusy:false
};

const dom = {
  backLink:document.getElementById("backLink"),
  chipText:document.getElementById("chipText"),
  battleTitle:document.getElementById("battleTitle"),
  battleSubtitle:document.getElementById("battleSubtitle"),
  battleSectionTitle:document.getElementById("battleSectionTitle"),
  metricDownloadLabel:document.getElementById("metricDownloadLabel"),
  metricResultLabel:document.getElementById("metricResultLabel"),
  metricGatewayLabel:document.getElementById("metricGatewayLabel"),
  metricSupabaseLabel:document.getElementById("metricSupabaseLabel"),
  downloadsValue:document.getElementById("downloadsValue"),
  resultStatus:document.getElementById("resultStatus"),
  gatewayStatus:document.getElementById("gatewayStatus"),
  supabaseStatus:document.getElementById("supabaseStatus"),
  leftImage:document.getElementById("leftImage"),
  rightImage:document.getElementById("rightImage"),
  leftName:document.getElementById("leftName"),
  rightName:document.getElementById("rightName"),
  sideRow:document.getElementById("sideRow"),
  bars:document.getElementById("bars"),
  packRow:document.getElementById("packRow"),
  voteTitle:document.getElementById("voteTitle"),
  priceInfo:document.getElementById("priceInfo"),
  selectionSummary:document.getElementById("selectionSummary"),
  apiPill:document.getElementById("apiPill"),
  gatewayPill:document.getElementById("gatewayPill"),
  payBtn:document.getElementById("payBtn"),
  payNotice:document.getElementById("payNotice"),
  insightTitle:document.getElementById("insightTitle"),
  myStatsTitle:document.getElementById("myStatsTitle"),
  myPaidVotesLabel:document.getElementById("myPaidVotesLabel"),
  myWeightedLabel:document.getElementById("myWeightedLabel"),
  mySharesLabel:document.getElementById("mySharesLabel"),
  myPaidVotesValue:document.getElementById("myPaidVotesValue"),
  myWeightedValue:document.getElementById("myWeightedValue"),
  mySharesValue:document.getElementById("mySharesValue"),
  leaderboardTitle:document.getElementById("leaderboardTitle"),
  leaderboardList:document.getElementById("leaderboardList"),
  prizeTitle:document.getElementById("prizeTitle"),
  prizeList:document.getElementById("prizeList"),
  ruleLine:document.getElementById("ruleLine"),
  shareLinkBtn:document.getElementById("shareLinkBtn"),
  toast:document.getElementById("toast")
};

function getLangCode(){
  const raw = String(window.USER_LANG || localStorage.getItem("lang") || "en").toLowerCase();
  if(raw.startsWith("hi")) return "hi";
  if(raw.startsWith("it")) return "it";
  return "en";
}

let LANG_CODE = getLangCode();

const I18N = {
  en: {
    back_to_contest:"Back to Contest List",
    chip:"NOVAGAPP VS BATTLE",
    loading:"Loading...",
    metric_download:"Download Gate",
    metric_result:"Result Status",
    metric_gateway:"Gateway",
    metric_supabase:"Supabase Sync",
    result_locked:"Locked until 5M",
    result_open:"Unlocked",
    gateway_online:"Online",
    gateway_pending:"Pending",
    gateway_offline:"Disconnected",
    supabase_online:"Connected",
    supabase_offline:"Disconnected",
    supabase_local:"Local only",
    battle_section_title:"Left Side vs Right Side",
    vote_title:"Voting and Pricing",
    pricing_line:"1 Vote = $5, 7 Votes = $25, 20 Votes = $50",
    pay_now:"Pay and Vote",
    pay_processing:"Processing payment...",
    pay_ready_notice:"Real Razorpay payment will open after side and pack selection.",
    gateway_not_ready_notice:"Razorpay live keys are not configured on the server.",
    gateway_live_required_notice:"Razorpay is in test mode. Set live keys before publish.",
    api_offline_notice:"Contest server connection failed. Check live API base.",
    prizes_title:"Contest Prizes and Rules",
    share_dashboard:"Share Dashboard",
    result_rule_line:"Result will be announced only after app downloads reach 5,000,000.",
    votes_label:"votes",
    api_order_block:"Payment blocked because live contest API is unreachable.",
    razorpay_missing:"Razorpay not loaded",
    login_required_notice:"Please login first to pay and vote.",
    select_side_pack:"Select side and vote pack",
    vote_success:"Vote success",
    verify_failed:"Payment verify failed: ",
    payment_failed:"Payment failed",
    order_failed:"Order creation failed: ",
    order_retrying:"Rechecking contest API and retrying payment...",
    no_contest:"Contest data unavailable",
    open_from_list:"Open from contest list",
    selection_prompt:"Select side and pack to continue checkout.",
    selection_need_both:"Choose side and vote pack before payment.",
    selection_need_side:"Choose a side before payment.",
    selection_need_pack:"Choose a vote pack before payment.",
    selection_ready:"Ready to pay",
    payment_cancelled:"Payment window closed.",
    verify_retry_notice:"Payment received, but vote verification failed. Please try again.",
    pending_verify_notice:"Pending payment verification in progress...",
    api_pill_online:"API Online",
    api_pill_offline:"API Offline",
    gateway_pill_online:"Gateway Ready",
    gateway_pill_pending:"Gateway Pending",
    gateway_pill_offline:"Gateway Offline",
    insight_title:"Live Contest Insights",
    my_stats_title:"My Participation",
    my_paid_votes:"Paid votes",
    my_weighted_entries:"Weighted entries",
    my_share_actions:"Share actions",
    leaderboard_title:"Top Supporters",
    no_supporters:"No supporters yet",
    best_value:"Best Value",
    most_popular:"Most Popular"
  },
  hi: {
    back_to_contest:"Contest list par wapas",
    chip:"NOVAGAPP VS BATTLE",
    loading:"Load ho raha hai...",
    metric_download:"Download Gate",
    metric_result:"Result Status",
    metric_gateway:"Gateway",
    metric_supabase:"Supabase Sync",
    result_locked:"5M tak locked",
    result_open:"Unlocked",
    gateway_online:"Online",
    gateway_pending:"Pending",
    gateway_offline:"Connection nahi hai",
    supabase_online:"Connected",
    supabase_offline:"Disconnected",
    supabase_local:"Local only",
    battle_section_title:"Left side vs Right side",
    vote_title:"Voting aur Pricing",
    pricing_line:"1 Vote = $5, 7 Votes = $25, 20 Votes = $50",
    pay_now:"Pay aur Vote",
    pay_processing:"Payment process ho raha hai...",
    pay_ready_notice:"Side aur pack select karte hi real Razorpay payment open hoga.",
    gateway_not_ready_notice:"Server par Razorpay live keys set nahi hain.",
    gateway_live_required_notice:"Razorpay test mode me hai. Publish se pehle live keys set karo.",
    api_offline_notice:"Contest server connection fail hua. Live API base check karo.",
    prizes_title:"Contest Prizes aur Rules",
    share_dashboard:"Share Dashboard",
    result_rule_line:"Result tab announce hoga jab app downloads 5,000,000 complete honge.",
    votes_label:"votes",
    api_order_block:"Live contest API unreachable hai, payment blocked hai.",
    razorpay_missing:"Razorpay load nahi hua",
    login_required_notice:"Pay aur vote karne se pehle login karo.",
    select_side_pack:"Pehle side aur vote pack select karo",
    vote_success:"Vote successful",
    verify_failed:"Payment verify fail: ",
    payment_failed:"Payment failed",
    order_failed:"Order creation fail: ",
    order_retrying:"Contest API dobara check karke payment retry ho raha hai...",
    no_contest:"Contest data available nahi hai",
    open_from_list:"Contest list se open karo",
    selection_prompt:"Checkout continue karne ke liye side aur pack select karo.",
    selection_need_both:"Payment se pehle side aur vote pack choose karo.",
    selection_need_side:"Payment se pehle side choose karo.",
    selection_need_pack:"Payment se pehle vote pack choose karo.",
    selection_ready:"Payment ready",
    payment_cancelled:"Payment window close ho gayi.",
    verify_retry_notice:"Payment mil gaya, par vote verification fail hua. Dobara try karo.",
    pending_verify_notice:"Pending payment verification chal raha hai...",
    api_pill_online:"API Online",
    api_pill_offline:"API Offline",
    gateway_pill_online:"Gateway Ready",
    gateway_pill_pending:"Gateway Pending",
    gateway_pill_offline:"Gateway Offline",
    insight_title:"Live Contest Insights",
    my_stats_title:"Meri Participation",
    my_paid_votes:"Paid votes",
    my_weighted_entries:"Weighted entries",
    my_share_actions:"Share actions",
    leaderboard_title:"Top Supporters",
    no_supporters:"Abhi supporters nahi hain",
    best_value:"Best Value",
    most_popular:"Most Popular"
  },
  it: {
    back_to_contest:"Torna alla lista contest",
    chip:"NOVAGAPP VS BATTLE",
    loading:"Caricamento...",
    metric_download:"Download Gate",
    metric_result:"Stato Risultato",
    metric_gateway:"Gateway",
    metric_supabase:"Sync Supabase",
    result_locked:"Bloccato fino a 5M",
    result_open:"Sbloccato",
    gateway_online:"Online",
    gateway_pending:"In attesa",
    gateway_offline:"Connessione assente",
    supabase_online:"Connesso",
    supabase_offline:"Disconnesso",
    supabase_local:"Solo locale",
    battle_section_title:"Lato sinistro vs lato destro",
    vote_title:"Votazione e Prezzi",
    pricing_line:"1 voto = $5, 7 voti = $25, 20 voti = $50",
    pay_now:"Paga e vota",
    pay_processing:"Pagamento in corso...",
    pay_ready_notice:"Il pagamento Razorpay reale si apre dopo aver scelto lato e pacchetto.",
    gateway_not_ready_notice:"Le chiavi live Razorpay non sono configurate sul server.",
    gateway_live_required_notice:"Razorpay e in modalita test. Imposta chiavi live prima della pubblicazione.",
    api_offline_notice:"Connessione al server contest fallita. Verifica API base live.",
    prizes_title:"Premi e Regole Contest",
    share_dashboard:"Dashboard Share",
    result_rule_line:"Il risultato sara annunciato solo dopo 5.000.000 download.",
    votes_label:"voti",
    api_order_block:"Pagamento bloccato: API contest live non raggiungibile.",
    razorpay_missing:"Razorpay non caricato",
    login_required_notice:"Accedi prima di pagare e votare.",
    select_side_pack:"Seleziona lato e pacchetto voto",
    vote_success:"Voto registrato",
    verify_failed:"Verifica pagamento fallita: ",
    payment_failed:"Pagamento fallito",
    order_failed:"Creazione ordine fallita: ",
    order_retrying:"Controllo API contest e nuovo tentativo pagamento...",
    no_contest:"Dati contest non disponibili",
    open_from_list:"Apri dalla lista contest",
    selection_prompt:"Seleziona lato e pacchetto per continuare il checkout.",
    selection_need_both:"Scegli lato e pacchetto voto prima del pagamento.",
    selection_need_side:"Scegli un lato prima del pagamento.",
    selection_need_pack:"Scegli un pacchetto voto prima del pagamento.",
    selection_ready:"Pronto al pagamento",
    payment_cancelled:"Finestra pagamento chiusa.",
    verify_retry_notice:"Pagamento ricevuto, ma verifica voto fallita. Riprova.",
    pending_verify_notice:"Verifica pagamento in sospeso in corso...",
    api_pill_online:"API Online",
    api_pill_offline:"API Offline",
    gateway_pill_online:"Gateway Pronto",
    gateway_pill_pending:"Gateway In attesa",
    gateway_pill_offline:"Gateway Offline",
    insight_title:"Insight Contest Live",
    my_stats_title:"La mia partecipazione",
    my_paid_votes:"Voti pagati",
    my_weighted_entries:"Ingressi ponderati",
    my_share_actions:"Azioni share",
    leaderboard_title:"Top Supporter",
    no_supporters:"Nessun supporter",
    best_value:"Miglior valore",
    most_popular:"Piu popolare"
  }
};
function tr(key){
  const dict = I18N[LANG_CODE] || I18N.en;
  return dict[key] ?? I18N.en[key] ?? key;
}

function applyLanguage(){
  LANG_CODE = getLangCode();
  try{ document.documentElement.lang = LANG_CODE; }catch(_){ }
  if(dom.backLink) dom.backLink.textContent = tr("back_to_contest");
  if(dom.chipText) dom.chipText.textContent = tr("chip");
  if(dom.battleSubtitle && !state.data) dom.battleSubtitle.textContent = tr("loading");
  if(dom.metricDownloadLabel) dom.metricDownloadLabel.textContent = tr("metric_download");
  if(dom.metricResultLabel) dom.metricResultLabel.textContent = tr("metric_result");
  if(dom.metricGatewayLabel) dom.metricGatewayLabel.textContent = tr("metric_gateway");
  if(dom.metricSupabaseLabel) dom.metricSupabaseLabel.textContent = tr("metric_supabase");
  if(dom.battleSectionTitle) dom.battleSectionTitle.textContent = tr("battle_section_title");
  if(dom.voteTitle) dom.voteTitle.textContent = tr("vote_title");
  if(dom.priceInfo) dom.priceInfo.textContent = tr("pricing_line");
  if(dom.selectionSummary) dom.selectionSummary.textContent = tr("selection_prompt");
  if(dom.apiPill) dom.apiPill.textContent = tr("api_pill_offline");
  if(dom.gatewayPill) dom.gatewayPill.textContent = tr("gateway_pill_pending");
  if(dom.prizeTitle) dom.prizeTitle.textContent = tr("prizes_title");
  if(dom.shareLinkBtn) dom.shareLinkBtn.textContent = tr("share_dashboard");
  if(dom.insightTitle) dom.insightTitle.textContent = tr("insight_title");
  if(dom.myStatsTitle) dom.myStatsTitle.textContent = tr("my_stats_title");
  if(dom.myPaidVotesLabel) dom.myPaidVotesLabel.textContent = tr("my_paid_votes");
  if(dom.myWeightedLabel) dom.myWeightedLabel.textContent = tr("my_weighted_entries");
  if(dom.mySharesLabel) dom.mySharesLabel.textContent = tr("my_share_actions");
  if(dom.leaderboardTitle) dom.leaderboardTitle.textContent = tr("leaderboard_title");

  if(state.data) render();
}

function fmtInt(v){ return new Intl.NumberFormat("en-US").format(Math.max(0,Number(v)||0)); }
function esc(v){ return String(v||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;").replace(/'/g,"&#39;"); }
function safeNum(v){ const n=Number(v||0); return Number.isFinite(n)?n:0; }
function showToast(msg, isError){
  if(!msg) return;
  dom.toast.textContent = msg;
  dom.toast.className = "toast show " + (isError ? "err" : "ok");
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>dom.toast.className="toast",2200);
}

function readPendingVerifications(){
  try{
    const raw = JSON.parse(localStorage.getItem(PENDING_VERIFY_STORAGE_KEY) || "[]");
    if(!Array.isArray(raw)) return [];
    return raw
      .filter(item => item && typeof item === "object")
      .map(item => ({
        user_id: String(item.user_id || "").trim(),
        user_name: String(item.user_name || "").trim(),
        razorpay_order_id: String(item.razorpay_order_id || "").trim(),
        razorpay_payment_id: String(item.razorpay_payment_id || "").trim(),
        razorpay_signature: String(item.razorpay_signature || "").trim()
      }))
      .filter(item => item.razorpay_order_id && item.razorpay_payment_id && item.razorpay_signature);
  }catch(_){
    return [];
  }
}

function persistPendingVerifications(){
  try{
    localStorage.setItem(PENDING_VERIFY_STORAGE_KEY, JSON.stringify(state.pendingVerifications || []));
  }catch(_){ }
}

function queuePendingVerification(payload){
  if(!payload?.razorpay_order_id) return;
  const next = {
    user_id: String(payload.user_id || state.userId || "").trim(),
    user_name: String(payload.user_name || state.userName || "").trim(),
    razorpay_order_id: String(payload.razorpay_order_id || "").trim(),
    razorpay_payment_id: String(payload.razorpay_payment_id || "").trim(),
    razorpay_signature: String(payload.razorpay_signature || "").trim()
  };
  if(!next.razorpay_order_id || !next.razorpay_payment_id || !next.razorpay_signature) return;
  const idx = state.pendingVerifications.findIndex(item => item.razorpay_order_id === next.razorpay_order_id);
  if(idx >= 0){
    state.pendingVerifications[idx] = next;
  }else{
    state.pendingVerifications.push(next);
  }
  persistPendingVerifications();
}

function removePendingVerification(orderId){
  const oid = String(orderId || "").trim();
  if(!oid) return;
  const before = state.pendingVerifications.length;
  state.pendingVerifications = state.pendingVerifications.filter(item => item.razorpay_order_id !== oid);
  if(state.pendingVerifications.length !== before){
    persistPendingVerifications();
  }
}

function isRetryableNetworkError(err){
  const raw = String(err?.message || "").toLowerCase();
  return raw.includes("failed to fetch")
    || raw.includes("network")
    || raw.includes("connection")
    || raw.includes("econnrefused")
    || raw.includes("enotfound")
    || raw.includes("timeout")
    || raw.includes("503");
}

function isHardVerifyFailure(err){
  const raw = String(err?.message || "").toLowerCase();
  return raw.includes("invalid_payment_signature")
    || raw.includes("payment_fields_required")
    || raw.includes("order_not_found")
    || raw.includes("order_user_mismatch");
}

function ensureRazorpayLoaded(){
  if(window.Razorpay) return Promise.resolve(true);
  if(ensureRazorpayLoaded._promise) return ensureRazorpayLoaded._promise;
  ensureRazorpayLoaded._promise = new Promise((resolve, reject) => {
    const existing = document.querySelector('script[data-role="razorpay-sdk"]');
    if(existing){
      existing.addEventListener("load", () => resolve(Boolean(window.Razorpay)), { once:true });
      existing.addEventListener("error", () => reject(new Error(tr("razorpay_missing"))), { once:true });
      return;
    }
    const script = document.createElement("script");
    script.src = RAZORPAY_SDK_URL;
    script.async = true;
    script.setAttribute("data-role", "razorpay-sdk");
    script.onload = () => {
      if(window.Razorpay){
        resolve(true);
      }else{
        reject(new Error(tr("razorpay_missing")));
      }
    };
    script.onerror = () => reject(new Error(tr("razorpay_missing")));
    document.head.appendChild(script);
  }).catch(err => {
    ensureRazorpayLoaded._promise = null;
    throw err;
  });
  return ensureRazorpayLoaded._promise;
}

function avatarData(name){
  const initials = String(name||"NV").trim().split(/\s+/).map(x=>x[0]).join("").slice(0,2).toUpperCase() || "NV";
  const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#ff6a00"/><stop offset="100%" stop-color="#ff9345"/></linearGradient></defs><rect width="160" height="160" rx="80" fill="url(#g)"/><text x="80" y="94" text-anchor="middle" font-family="Arial" font-size="42" font-weight="700" fill="#fff">'+ initials +'</text></svg>';
  return "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);
}

function setPosterWithFallback(imgEl, src, fallbackLabel){
  const fallback = avatarData(fallbackLabel);
  const raw = String(src || "").trim();
  const attempts = [];
  const isClearlyInvalid = (value) => {
    const v = String(value || "").trim();
    if(!v) return true;
    if(v === "data:;base64," || v === "data:,") return true;
    return false;
  };
  if(!isClearlyInvalid(raw)) attempts.push(raw);
  if(/^images\//i.test(raw)){
    attempts.push(raw.replace(/^images\//i, "Images/"));
  }
  if(/^Images\//.test(raw)){
    attempts.push(raw.replace(/^Images\//, "images/"));
  }
  attempts.push("Images/logo.png");
  const uniqAttempts = attempts.filter((value, idx) => attempts.indexOf(value) === idx && !isClearlyInvalid(value));

  let idx = 0;
  const next = () => {
    if(idx >= uniqAttempts.length){
      imgEl.onerror = null;
      imgEl.src = fallback;
      return;
    }
    imgEl.src = uniqAttempts[idx];
    idx += 1;
  };

  imgEl.onerror = next;
  next();
}

function normalizeBase(base){
  return String(base || "").trim().replace(/\/+$/g, "");
}

function isLoopbackBase(base){
  const normalized = normalizeBase(base);
  if(!normalized) return false;
  try{
    const host = String(new URL(normalized).hostname || "").toLowerCase();
    return host === "127.0.0.1" || host === "localhost";
  }catch(_){
    return false;
  }
}

function clearStoredApiBase(){
  try{
    localStorage.removeItem("contest_api_base");
    localStorage.removeItem("api_base");
  }catch(_){ }
}

function persistApiBase(base){
  const normalized = normalizeBase(base);
  if(!normalized) return;
  if(isLoopbackBase(normalized) && !allowLoopbackApiBase()){
    clearStoredApiBase();
    return;
  }
  try{
    localStorage.setItem("contest_api_base", normalized);
    localStorage.setItem("api_base", normalized);
  }catch(_){ }
}

function canUseRelativeApiPath(){
  return String(location.port || "") === "3000";
}

function allowLoopbackApiBase(){
  if(canUseRelativeApiPath()) return true;
  const host = String(location.hostname || "").toLowerCase();
  if(location.protocol === "file:" || host === "localhost" || host === "127.0.0.1"){
    return true;
  }
  const params = new URLSearchParams(location.search);
  const raw = String(
    params.get("allow_local_api") ||
    params.get("force_local_api") ||
    params.get("local_api") ||
    ""
  ).trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes";
}

function isLocalRuntime(){
  const host = String(location.hostname || "").toLowerCase();
  return location.protocol === "file:"
    || host === "localhost"
    || host === "127.0.0.1";
}

function isLikelySupabaseUserId(value){
  const raw = String(value || "").trim();
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(raw);
}

function isLoggedInContestUser(){
  return isLikelySupabaseUserId(state.userId);
}

function getPaymentGatewayMode(){
  return String(state.data?.payment_gateway_mode || "").trim().toLowerCase();
}

function getPaymentGatewayIssue(){
  return String(state.data?.payment_gateway_issue || "").trim().toLowerCase();
}

function isGatewayBlockedByMode(){
  if(getPaymentGatewayIssue() === "live_key_required"){
    return true;
  }
  const mode = getPaymentGatewayMode();
  if(mode === "test" && !isLocalRuntime()){
    return true;
  }
  return false;
}

function resolveInitialApiBase(){
  const params = new URLSearchParams(location.search);
  const queryRaw = String(params.get("api_base") || "").trim();
  const allowLoopback = allowLoopbackApiBase();
  const fromQuery = normalizeBase(queryRaw);
  if(fromQuery){
    if(!(isLoopbackBase(fromQuery) && !allowLoopback)){
      persistApiBase(fromQuery);
      return fromQuery;
    }
    clearStoredApiBase();
  }

  let fromStorage = "";
  try{
    fromStorage = normalizeBase(localStorage.getItem("contest_api_base") || localStorage.getItem("api_base") || "");
  }catch(_){ }
  if(fromStorage){
    const skipStoredLoopback = !allowLoopback && isLoopbackBase(fromStorage);
    if(skipStoredLoopback){
      clearStoredApiBase();
    }else{
      return fromStorage;
    }
  }

  const fromGlobal = normalizeBase(window.CONTEST_API_BASE || window.API_BASE || "");
  if(fromGlobal && !(isLoopbackBase(fromGlobal) && !allowLoopback)){
    return fromGlobal;
  }

  if(canUseRelativeApiPath()) return "";
  return "";
}

function buildApiBaseCandidates(){
  const params = new URLSearchParams(location.search);
  const allowLoopback = allowLoopbackApiBase();
  const list = [];
  const pushBase = (base) => {
    const normalized = normalizeBase(base);
    if(normalized === "" && !canUseRelativeApiPath()) return;
    if(!allowLoopback && isLoopbackBase(normalized)) return;
    if(list.includes(normalized)) return;
    list.push(normalized);
  };

  pushBase(state.apiBase);
  pushBase(params.get("api_base"));

  try{
    pushBase(localStorage.getItem("contest_api_base"));
    pushBase(localStorage.getItem("api_base"));
  }catch(_){ }
  pushBase(window.CONTEST_API_BASE || window.API_BASE || "");

  if(canUseRelativeApiPath()){
    pushBase("");
  }
  return list;
}

async function probeApiBase(suffix){
  const candidates = buildApiBaseCandidates();
  if(!candidates.length){
    throw new Error(tr("api_offline_notice"));
  }
  let lastError = null;

  for(const base of candidates){
    try{
      const payload = await fetchJson((base ? (base + suffix) : suffix), { method:"GET" });
      if(payload?.data){
        state.apiBase = base;
        persistApiBase(base);
        return payload;
      }
    }catch(err){
      lastError = err;
    }
  }

  throw (lastError || new Error(tr("api_offline_notice")));
}

function apiUrl(path){ return state.apiBase ? state.apiBase + path : path; }

async function fetchJson(url,opt){
  const res = await fetch(url,opt);
  const data = await res.json().catch(()=>({}));
  if(!res.ok || !data?.ok){
    throw new Error(data?.message || data?.error || ("Request failed: " + res.status));
  }
  return data;
}

function postJson(path,payload){
  return fetchJson(apiUrl(path), {
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify(payload||{})
  });
}

function getStoredUser(){
  try{
    const raw = JSON.parse(localStorage.getItem("user") || "{}");
    return raw && typeof raw === "object" ? raw : {};
  }catch(_){
    return {};
  }
}

function getUserFromSupabaseStorage(){
  try{
    for(let i = 0; i < localStorage.length; i += 1){
      const key = String(localStorage.key(i) || "");
      if(!key.startsWith("sb-") || !key.endsWith("-auth-token")) continue;
      const value = localStorage.getItem(key);
      if(!value) continue;
      const parsed = JSON.parse(value);
      const user = parsed?.user || parsed?.currentSession?.user || parsed?.session?.user || null;
      if(user?.id) return user;
    }
  }catch(_){ }
  return null;
}

async function initUser(){
  state.supabaseSessionReady = Boolean(supa?.auth || window.supa?.auth);
  const stored = getStoredUser();
  if(stored?.uid){
    state.userId = String(stored.uid || "");
    state.userName = String(stored.name || "");
    state.userEmail = String(stored.email || "");
  }

  const authClients = [];
  if(window.supa?.auth) authClients.push(window.supa);
  if(supa?.auth && supa !== window.supa) authClients.push(supa);

  for(const client of authClients){
    try{
      const sessionRes = await client.auth.getSession();
      if(!sessionRes?.error) state.supabaseSessionReady = true;
      const sessionUser = sessionRes?.data?.session?.user || null;
      if(sessionUser?.id){
        state.userId = sessionUser.id || state.userId;
        state.userEmail = sessionUser.email || state.userEmail;
        state.userName = sessionUser.user_metadata?.full_name || sessionUser.user_metadata?.name || state.userName || "";
        break;
      }
    }catch(_){ }
  }

  if(!state.userId){
    for(const client of authClients){
      try{
        const userRes = await client.auth.getUser();
        if(!userRes?.error) state.supabaseSessionReady = true;
        const user = userRes?.data?.user || null;
        if(user?.id){
          state.userId = user.id || state.userId;
          state.userEmail = user.email || state.userEmail;
          state.userName = user.user_metadata?.full_name || user.user_metadata?.name || state.userName || "";
          break;
        }
      }catch(_){ }
    }
  }

  if(!state.userId){
    const storageUser = getUserFromSupabaseStorage();
    if(storageUser?.id){
      state.supabaseSessionReady = true;
      state.userId = storageUser.id || state.userId;
      state.userEmail = storageUser.email || state.userEmail;
      state.userName = storageUser.user_metadata?.full_name || storageUser.user_metadata?.name || state.userName || "";
    }
  }

  if(!state.userName && state.userEmail){
    state.userName = String(state.userEmail.split("@")[0] || "").trim();
  }

  if(state.userId && !isLikelySupabaseUserId(state.userId)){
    state.userId = "";
  }

  if(state.userId){
    try{
      localStorage.setItem("user", JSON.stringify({
        uid: state.userId,
        name: state.userName || "",
        email: state.userEmail || ""
      }));
    }catch(_){ }
  }else{
    try{
      localStorage.removeItem("contest_guest_user_id");
    }catch(_){ }
  }
}

function parseContestId(){
  const params = new URLSearchParams(location.search);
  const raw = String(params.get("contest") || "contest_1").trim().toLowerCase();
  const valid = /^contest_[1-6]$/.test(raw) ? raw : "contest_1";
  state.contestId = valid;
}

async function loadData(){
  const qp = new URLSearchParams();
  if(state.userId){
    qp.set("user_id", state.userId);
    if(state.userName) qp.set("user_name", state.userName);
  }
  const suffix = "/api/contest/dashboard" + (qp.toString() ? ("?" + qp.toString()) : "");
  const fetchDashboard = (base) => fetchJson((base ? (base + suffix) : suffix), { method:"GET" });
  const canTryPrimary = Boolean(state.apiBase) || canUseRelativeApiPath();

  let firstError = null;
  if(canTryPrimary){
    try{
      const payload = await fetchDashboard(state.apiBase);
      state.data = payload?.data || null;
      if(!state.data){
        throw new Error(tr("api_offline_notice"));
      }
      persistApiBase(state.apiBase);
      state.apiError = "";
      return;
    }catch(err){
      firstError = err;
    }
  }

  try{
    const payload = await probeApiBase(suffix);
    state.data = payload?.data || null;
    state.apiError = "";
  }catch(probeErr){
    state.data = null;
    state.apiError = String(
      probeErr?.message ||
      firstError?.message ||
      tr("api_offline_notice")
    ).trim() || tr("api_offline_notice");
  }
}

function bindApiAutoRetry(){
  if(bindApiAutoRetry._bound) return;
  bindApiAutoRetry._bound = true;

  const retry = async () => {
    if(state.apiRetryBusy) return;
    if(state.paymentBusy) return;
    if(document.visibilityState === "hidden") return;
    if(!state.apiError) return;
    state.apiRetryBusy = true;
    try{
      await loadData();
      render();
    }catch(_){ }
    state.apiRetryBusy = false;
  };

  state.apiRetryTimer = setInterval(retry, 5000);
  document.addEventListener("visibilitychange", () => {
    if(document.visibilityState === "visible"){
      retry();
    }
  });
  window.addEventListener("beforeunload", () => {
    if(state.apiRetryTimer){
      clearInterval(state.apiRetryTimer);
      state.apiRetryTimer = 0;
    }
  }, { once:true });
}

async function verifyVotePayment(payload, opts){
  const options = opts || {};
  await postJson("/api/contest/order/verify", payload);
  removePendingVerification(payload?.razorpay_order_id);
  if(options.refresh !== false){
    await loadData();
    render();
  }
  if(!options.silentSuccess){
    showToast(tr("vote_success"), false);
  }
}

async function flushPendingVerifications(opts){
  const options = opts || {};
  const queue = [...state.pendingVerifications];
  if(!queue.length) return;
  let updated = false;
  if(!options.silent){
    showToast(tr("pending_verify_notice"), false);
  }
  for(const item of queue){
    try{
      await verifyVotePayment(item, { refresh:false, silentSuccess:true });
      updated = true;
    }catch(err){
      if(isHardVerifyFailure(err)){
        removePendingVerification(item.razorpay_order_id);
      }
    }
  }
  if(updated){
    await loadData();
    render();
    if(!options.silent){
      showToast(tr("vote_success"), false);
    }
  }
}

function getContest(){
  return (state.data?.contests || []).find(c => c.id === state.contestId) || null;
}

function setPill(node, text, tone){
  if(!node) return;
  node.textContent = text;
  const next = ["pill"];
  if(tone === "good") next.push("good");
  if(tone === "bad") next.push("bad");
  node.className = next.join(" ");
}

function render(){
  const supabaseSyncReady = Boolean(state.data?.supabase_sync_ready);
  const supabaseStatusText = supabaseSyncReady
    ? tr("supabase_online")
    : (state.supabaseSessionReady ? tr("supabase_local") : tr("supabase_offline"));
  const gatewayIssue = getPaymentGatewayIssue();
  const gatewayBlockedByMode = isGatewayBlockedByMode();

  if(!state.data){
    dom.downloadsValue.textContent = "-- / --";
    dom.resultStatus.textContent = "--";
    dom.gatewayStatus.textContent = tr("gateway_offline");
    dom.supabaseStatus.textContent = supabaseStatusText;
    dom.battleTitle.textContent = tr("no_contest");
    dom.battleSubtitle.textContent = state.apiError || tr("api_offline_notice");
    dom.sideRow.innerHTML = "";
    dom.bars.innerHTML = "";
    dom.packRow.innerHTML = "";
    dom.prizeList.innerHTML = "";
    dom.leaderboardList.innerHTML = "<li><span class=\"leader-name\">"+esc(tr("no_supporters"))+"</span><span class=\"leader-score\">--</span></li>";
    dom.myPaidVotesValue.textContent = "0";
    dom.myWeightedValue.textContent = "0";
    dom.mySharesValue.textContent = "0";
    dom.ruleLine.textContent = "";
    dom.payBtn.textContent = tr("pay_now");
    dom.payBtn.disabled = true;
    dom.selectionSummary.textContent = state.apiError || tr("selection_prompt");
    setPill(dom.apiPill, tr("api_pill_offline"), "bad");
    setPill(dom.gatewayPill, tr("gateway_pill_offline"), "bad");
    dom.payNotice.textContent = state.apiError || tr("api_offline_notice");
    return;
  }

  const contest = getContest();
  const packs = state.data?.packs || [];
  const userStats = state.data?.user_stats || {};
  const leaderboard = Array.isArray(state.data?.leaderboard) ? state.data.leaderboard : [];

  dom.downloadsValue.textContent = fmtInt(state.data?.current_downloads || 0) + " / " + fmtInt(state.data?.download_target || 5000000);
  dom.resultStatus.textContent = state.data?.results_ready ? tr("result_open") : tr("result_locked");
  dom.gatewayStatus.textContent = state.apiError
    ? tr("gateway_offline")
    : (state.data?.razorpay_ready ? tr("gateway_online") : tr("gateway_pending"));
  dom.supabaseStatus.textContent = supabaseStatusText;

  if(dom.priceInfo){
    if(packs.length){
      dom.priceInfo.textContent = packs
        .map(pack => {
          const votes = Math.max(0, Math.round(safeNum(pack.votes)));
          const usd = Math.max(0, safeNum(pack.usd));
          return votes + " " + tr("votes_label") + " = $" + usd;
        })
        .join(", ");
    }else{
      dom.priceInfo.textContent = tr("pricing_line");
    }
  }

  if(!contest){
    dom.battleTitle.textContent = tr("no_contest");
    dom.battleSubtitle.textContent = tr("open_from_list");
    dom.sideRow.innerHTML = "";
    dom.bars.innerHTML = "";
    dom.packRow.innerHTML = "";
    dom.prizeList.innerHTML = "";
    dom.payBtn.disabled = true;
    dom.selectionSummary.textContent = tr("selection_prompt");
    return;
  }

  dom.battleTitle.textContent = contest.title;
  dom.battleSubtitle.textContent = contest.subtitle;

  const leftLabel = contest?.sides?.[0]?.label || "Side 1";
  const rightLabel = contest?.sides?.[1]?.label || "Side 2";
  const sidePosters = CONTEST_SIDE_POSTERS[state.contestId] || {};
  dom.leftName.textContent = leftLabel;
  dom.rightName.textContent = rightLabel;
  dom.leftImage.alt = leftLabel + " poster";
  dom.rightImage.alt = rightLabel + " poster";
  setPosterWithFallback(dom.leftImage, sidePosters.left, leftLabel);
  setPosterWithFallback(dom.rightImage, sidePosters.right, rightLabel);

  if(!(contest.sides || []).some(side => side.id === state.selectedSide)){
    state.selectedSide = "";
  }
  if(!packs.some(pack => pack.id === state.selectedPack)){
    state.selectedPack = "";
  }

  dom.sideRow.innerHTML = (contest.sides || []).map(side => {
    const active = side.id === state.selectedSide ? " active" : "";
    return '<button type="button" class="side-btn'+active+'" data-side="'+esc(side.id)+'">'+esc(side.label)+'</button>';
  }).join("");

  const totalVotes = safeNum(contest.total_votes);
  dom.bars.innerHTML = (contest.sides || []).map(side => {
    const votes = safeNum(side.votes);
    const percent = totalVotes > 0 ? (votes * 100 / totalVotes) : 0;
    return '<div class="bar"><small><span>'+esc(side.label)+'</span><span>'+fmtInt(votes)+' '+esc(tr("votes_label"))+'</span></small><div class="track"><span style="width:'+percent.toFixed(2)+'%"></span></div></div>';
  }).join("");

  const bestPackRatio = packs.reduce((best, row) => {
    const rowVotes = Math.max(0, safeNum(row.votes));
    const rowUsd = Math.max(0, safeNum(row.usd));
    const ratio = rowUsd > 0 ? (rowVotes / rowUsd) : 0;
    return Math.max(best, ratio);
  }, 0);

  dom.packRow.innerHTML = packs.map(pack => {
    const active = pack.id === state.selectedPack ? " active" : "";
    const votes = Math.max(0, Math.round(safeNum(pack.votes)));
    const usd = Math.max(0, safeNum(pack.usd));
    const votePerDollar = usd > 0 ? (votes / usd) : 0;
    let tag = "";
    if(votePerDollar > 0 && Math.abs(votePerDollar - bestPackRatio) < 0.001){
      tag = tr("best_value");
    }else if(pack.id === "vote_7"){
      tag = tr("most_popular");
    }
    return [
      '<button type="button" class="pack-btn'+active+'" data-pack="'+esc(pack.id)+'">',
      (tag ? '<span class="pack-tag">'+esc(tag)+'</span>' : ""),
      '<span class="pack-label">'+esc(votes + " " + tr("votes_label"))+'</span>',
      '<span class="pack-price">$'+esc(usd)+'</span>',
      '</button>'
    ].join("");
  }).join("");

  dom.prizeList.innerHTML = (contest.prizes || []).map(row => "<li>"+esc(row)+"</li>").join("");
  dom.ruleLine.textContent = state.data?.result_rule || tr("result_rule_line");

  const selectedPack = packs.find(pack => pack.id === state.selectedPack) || null;
  const selectedSide = (contest.sides || []).find(side => side.id === state.selectedSide) || null;
  if(selectedPack && selectedSide){
    const votes = Math.max(0, Math.round(safeNum(selectedPack.votes)));
    const usd = Math.max(0, safeNum(selectedPack.usd));
    dom.selectionSummary.textContent = tr("selection_ready") + ": " + selectedSide.label + " | " + votes + " " + tr("votes_label") + " | $" + usd;
  }else if(!selectedSide && !selectedPack){
    dom.selectionSummary.textContent = tr("selection_need_both");
  }else if(!selectedSide){
    dom.selectionSummary.textContent = tr("selection_need_side");
  }else{
    dom.selectionSummary.textContent = tr("selection_need_pack");
  }

  const apiOnline = !state.apiError;
  const loginReady = isLoggedInContestUser();
  const gatewayOnline = Boolean(state.data?.razorpay_ready) && !state.apiError && !gatewayBlockedByMode;
  setPill(dom.apiPill, apiOnline ? tr("api_pill_online") : tr("api_pill_offline"), apiOnline ? "good" : "bad");
  setPill(
    dom.gatewayPill,
    gatewayOnline
      ? tr("gateway_pill_online")
      : (state.apiError || gatewayBlockedByMode ? tr("gateway_pill_offline") : tr("gateway_pill_pending")),
    gatewayOnline ? "good" : (state.apiError || gatewayBlockedByMode ? "bad" : "")
  );

  dom.myPaidVotesValue.textContent = fmtInt(safeNum(userStats?.paid_votes));
  dom.myWeightedValue.textContent = String(Math.round(safeNum(userStats?.weighted_entries) * 100) / 100);
  dom.mySharesValue.textContent = fmtInt(safeNum(userStats?.share_actions));

  const boardRows = leaderboard.slice(0, 5);
  if(!boardRows.length){
    dom.leaderboardList.innerHTML = "<li><span class=\"leader-name\">"+esc(tr("no_supporters"))+"</span><span class=\"leader-score\">--</span></li>";
  }else{
    dom.leaderboardList.innerHTML = boardRows.map(row => {
      const name = row?.display_name || "User";
      const score = safeNum(row?.weighted_entries);
      return "<li><span class=\"leader-name\">#"+esc(row?.rank)+" "+esc(name)+"</span><span class=\"leader-score\">"+esc(score.toFixed(1))+"</span></li>";
    }).join("");
  }

  dom.payBtn.textContent = state.paymentBusy ? tr("pay_processing") : tr("pay_now");
  dom.payBtn.disabled = state.paymentBusy || !state.selectedSide || !state.selectedPack || !gatewayOnline || !loginReady;

  dom.shareLinkBtn.href = "contest.html" + (state.apiBase ? ("?api_base=" + encodeURIComponent(state.apiBase)) : "");
  if(state.paymentBusy){
    dom.payNotice.textContent = tr("pay_processing");
  }else if(!loginReady){
    dom.payNotice.textContent = tr("login_required_notice");
  }else if(state.apiError){
    dom.payNotice.textContent = tr("api_offline_notice");
  }else if(gatewayBlockedByMode || gatewayIssue === "live_key_required"){
    dom.payNotice.textContent = tr("gateway_live_required_notice");
  }else if(!state.data?.razorpay_ready){
    dom.payNotice.textContent = tr("gateway_not_ready_notice");
  }else if(selectedPack){
    const votes = Math.max(0, Math.round(safeNum(selectedPack.votes)));
    const usd = Math.max(0, safeNum(selectedPack.usd));
    dom.payNotice.textContent = tr("pay_ready_notice") + " " + votes + " " + tr("votes_label") + " | $" + usd;
  }else{
    dom.payNotice.textContent = tr("selection_need_pack");
  }
}

async function startPayment(){
  if(state.paymentBusy) return;
  if(state.apiError || !state.data){
    await loadData();
    render();
  }
  if(!state.data){
    showToast(tr("api_order_block"), true);
    return;
  }
  if(!state.data?.razorpay_ready){
    showToast(tr("gateway_not_ready_notice"), true);
    return;
  }
  if(isGatewayBlockedByMode() || getPaymentGatewayIssue() === "live_key_required"){
    showToast(tr("gateway_live_required_notice"), true);
    return;
  }
  if(!isLoggedInContestUser()){
    showToast(tr("login_required_notice"), true);
    return;
  }

  const contest = getContest();
  if(!contest || !state.selectedSide || !state.selectedPack){
    showToast(tr("select_side_pack"), true);
    return;
  }

  state.paymentBusy = true;
  render();

  try{
    await ensureRazorpayLoaded();

    const createOrder = () => postJson("/api/contest/order", {
      user_id: state.userId,
      user_name: state.userName || "",
      contest_id: state.contestId,
      side_id: state.selectedSide,
      pack_id: state.selectedPack
    });
    let orderPayload;
    try{
      orderPayload = await createOrder();
    }catch(firstErr){
      if(!isRetryableNetworkError(firstErr)) throw firstErr;

      showToast(tr("order_retrying"), true);
      await loadData();
      render();
      orderPayload = await createOrder();
    }

    const order = orderPayload?.order || null;
    if(!order?.razorpay_order_id || !order?.key_id){
      throw new Error("invalid_order_payload");
    }

    await new Promise((resolve, reject) => {
      let settled = false;
      const finish = (err) => {
        if(settled) return;
        settled = true;
        if(err){
          reject(err);
          return;
        }
        resolve(true);
      };

      const rzp = new Razorpay({
        key: order.key_id,
        order_id: order.razorpay_order_id,
        amount: order.amount_paise,
        currency: order.currency,
        name: "NOVAGAPP Contest Battle",
        description: contest.title,
        prefill:{ name:state.userName || "", email:state.userEmail || "" },
        theme:{ color:"#ff6a00" },
        retry:{ enabled:true, max_count:1 },
        modal:{
          confirm_close:true,
          escape:false,
          backdropclose:false,
          ondismiss: () => {
            const cancelled = new Error("payment_cancelled");
            cancelled.handled = true;
            showToast(tr("payment_cancelled"), true);
            finish(cancelled);
          }
        },
        handler: async (resp) => {
          const verifyPayload = {
            user_id: state.userId,
            user_name: state.userName || "",
            razorpay_order_id: String(resp?.razorpay_order_id || order.razorpay_order_id || "").trim(),
            razorpay_payment_id: String(resp?.razorpay_payment_id || "").trim(),
            razorpay_signature: String(resp?.razorpay_signature || "").trim()
          };

          if(!verifyPayload.razorpay_order_id || !verifyPayload.razorpay_payment_id || !verifyPayload.razorpay_signature){
            const invalid = new Error(tr("verify_failed") + "missing_fields");
            invalid.handled = true;
            showToast(invalid.message, true);
            finish(invalid);
            return;
          }

          try{
            await verifyVotePayment(verifyPayload, { refresh:true, silentSuccess:false });
            finish();
          }catch(err){
            removePendingVerification(verifyPayload.razorpay_order_id);
            showToast(tr("verify_failed") + (err?.message || ""), true);
            const verifyErr = new Error("verify_failed");
            verifyErr.handled = true;
            finish(verifyErr);
          }
        }
      });

      rzp.on("payment.failed", (evt) => {
        const msg = evt?.error?.description || tr("payment_failed");
        const failed = new Error(msg);
        failed.handled = true;
        showToast(msg, true);
        finish(failed);
      });

      try{
        rzp.open();
      }catch(err){
        finish(err);
      }
    });
  }catch(err){
    if(!err?.handled){
      showToast(tr("order_failed") + (err?.message || ""), true);
    }
  }finally{
    state.paymentBusy = false;
    render();
  }
}

function bindEvents(){
  dom.sideRow.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-side]");
    if(!btn) return;
    state.selectedSide = String(btn.getAttribute("data-side") || "");
    render();
  });

  dom.packRow.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-pack]");
    if(!btn) return;
    state.selectedPack = String(btn.getAttribute("data-pack") || "");
    render();
  });

  dom.payBtn.addEventListener("click", startPayment);
}

async function init(){
  if(window.__contestBattleInitDone) return;
  window.__contestBattleInitDone = true;

  state.pendingVerifications = readPendingVerifications();
  parseContestId();
  state.apiBase = resolveInitialApiBase();
  applyLanguage();
  document.addEventListener("languageUpdated", applyLanguage);
  await initUser();
  await loadData();
  bindApiAutoRetry();
  bindEvents();
  render();
}

if(!window.__contestBattleInitPromise){
  window.__contestBattleInitPromise = init().catch(err => {
    console.error("battle_init_error", err);
    showToast("Page load failed", true);
  });
}
</script>
</body>
</html>
